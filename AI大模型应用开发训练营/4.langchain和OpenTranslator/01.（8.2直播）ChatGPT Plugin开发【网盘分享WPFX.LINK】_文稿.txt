	好，那我们就直接开始。今天这个其实算是一个选修课程，然后也是我们基础篇的最后一课。今天讲这个ChatGPT的插件开发，我相信有的同学，我印象当中之前这个plug in的权限没有开放给所有的用户我不知道现在是不是所有的用户都能访问这个插件，以及是否能够基于这个ChatGPT的插件去做开发。如果不是的话，所以这个是一个选修的课，但是这个又很重要，为什么重要呢？
	我们就跳到今天的内容里面来，今天其实我们会讲两个ChatGPT的插件。一个是官方的最简单的一个插件，叫做to do的代办管理。就假设你有一个简单的项目，这个项目是像一个助理一样的，那个助理需要帮助我们的老板去记录他最近有什么代办的事项，然后可以帮他管理起来。这个是OpenAI官方提的一个简单的项目，就叫出租的一个管理。我们会简单的做一个介绍，就是上半节课让大家走一遍。
	第二个就是说我们在function call这一节课的时候跟大家做了一个展示，并且留了一个家庭作业，就是我们的这个天气预报，使用function calling是可以成功的让我们的ChatGPT去判断它。现在是在问询这个天气预报的，并且是在问两个函数当中的哪一个。那我们能不能把它演变成一个插件呢？我们做了这么一个实战的设计，并且端到端的把这个天气预报最后真的查出来了。对接了一个第三方的一个天气查询的平台，然后最后我们会把这个项目做成一个实战的项目，让大家实际去体验。最后会花一点时间跟大家分享一下我的一些办法，就关于这个function calling，chat PT plug in这两种不同的模式，对于咱们来说各自有什么优劣？以及对于我们要开发大模型应用来说的话，各自又有什么样的特点。
	OK我们就回到正题，这里稍微再花一点点时间介绍一下，就是我们之前在那个课程大纲里面有提到，是把咱们的那个翻译做成一个插件的实战。后来我们把这个翻译的开发，变成了这个项目的基础篇的一个结业的作业。所以我们就把那个事儿给变成一个家庭作业的形式让大家去做了。并且本身这个翻译没有太多的有滑头，跟这个天气预报其实是类似的。大家如果想要去做的话，其实应该更简单。因为翻译要去写它的function calling的定义也好，或者说今天咱们去用这个插件开发会介绍怎么样去定义API，那其实都是一样的。但这个模式学通之后，其实大家要去开发一个自己的插件。如果你有权限的话，是一个比较简单的事情，并且它和我们的function calling有很多相似之处。
	好，那我们今天就正式来介绍一下这个TIGPT的这个bug in首先ChatGPT的plug in是今年一季度的时候，我们就看到有一些声音。然后后来发了一个blog出来，就是有OpenAI发布的这样一个TGB的插件。他在发布这个插件的时候，其实当时是引发了很大的轰动。并且在那个时间节点，就是我们的GPT4刚刚发布没多久。然后大家发现这个GPT能力特别强，并且拥有了这个插件的能力，使得我们的GPT可以去做各种各样除了大语言模型聊天之外的工作。就比如说我们这里看到的刚刚那幅图，是他刚刚发布的那个日期。
	然后有一批这个插件，当时是官方发布出来，在5月45月份的时候。但是今天8月2号我们能看到，其实这个ChatGPT的插件生态，或者说插件的应用已经非常多了。这个是一个实际的截图，大家如果有这个插件权限的访问的话都能看得到。其实目前我们在ChatGPT的，我们叫插件市场里面看到的这个插件数量已经远远超过800个了。就我们能看到这里有一个页码数量，这一页是八个，其实已经不止100页了，也就这么几个月的时间。其实整个插件市场的发布是非非常快速的，然后有各种各样的应用在上面去做这个迭代，但这里也遇到了一些困难，就是说它这个形式上本身还是有一定的局限性的。
	我们就只是这样的一个，相当于不算是一个最高优先级的事儿。对于ChatGPT来说，它也是隐藏在里面，并且是有部分的用户可以去使用，包括像OpenAI自己的这个官方团队的这个也有在讲，就是说现在拆GPT的这个MVP也还没有把这个plug in给跑出来。那他们自己也发布了一个插件，就它的这个代码解释器算是他官方的一种插件形式了。这些也都在快速的迭代。所以最终我们的这个plug in市场会怎么样的一个走向，目前还不明朗。
	但是对于我们这个开发者来说，或者对于我们想要拥抱这个大语言模型应用开发的人来说，去了解ChatGPT的这个插件是如何开发的，以及如何跟咱们的应用去做对接，了解这个技术本身是很有价值的。因为它其实是一个承上启下的一个阶段。为什么我们把它放在了基础篇的最后一节课，并且作为一个选修呢？除了前面的原因以外，其实它跟我们接下来要学习的这个进阶南茜有一些观点。就南券也是一个以大语言模型为底层的一个支撑。然后让大语言模型来提供语义理解的能力，然后帮助我们去做很多比较复杂的工作，这样的一个框架。ChatGPT的八个in，其实我们可以把自己开发的这个插件应用也当成一个这样的视角。
	我们其实是在借助这个ChatGPT的能力去理解一些语义，然后同时能做更多的一些其他类型的应用。所以对于ChatGPT来说，它发展这个插件的市场和生态，其实它的愿景也很简单，就是能不能基于ChatGPT的能力，这个插件的形式去赋能千行百业。这个其实是ChatGPT plug in，从它的发布到现在为止，稍等关空调从它的发布。
	到现在。
	为止的一个历史进展和我们能看到他的开发者非常踊跃的在上面去提交新的项目。这是第一批OpenAI官方发布的时候带的这11个项目，到现在为止已经陆陆续续有有一千多个，我印象中有一千多个插件都已经发不出来了。如果咱们有权限的话，然后也可以在这个选修课这节课学完之后，根据你自己的需求，你也可以去搜一下有没有类似的这样的插件。如果没有的话，那可以鼓励大家去申请这个插件的发布。
	这里就回到一个开发者的问题了，就是既然插件生态这么几个月就有这么多人在提交自己的插件了，然后官方也把这个事自己也在做这个官方的插件，那开发这样的一个东西很难吗？应该具备什么样的一些关键的技术要点，我们就自己能做这事儿了。这个是一张样例项目，最简单的样例项目，在OpenAI quick star这个插件的里面做了一个非常简单的样例项目我们待会儿也会去实际的去体验一下这个项目他其实做了一个什么样的，就是我们刚刚提到的代办的管理。这个是一个实际的使用这个插件的一个对话。那它的形态也跟我们之前使用这个没有任何变化，都是在拆GPT的这个聊天界面里面，这个聊天的UI里面去使用这个插件。
	然后这个插件什么时候会被触发？其实跟咱们的这个function calling上上上节课讲的非常像。就是我们当时讲function calling的时候有一个很重要的事儿，就是我们要描述清楚我们的ChatGPT什么时候要调用我们的这个function，对吧？然后我们还可以指定它调用哪些function，根据我们传进去的这个functions，就我们传进去的这个函数名，就可以指定ChatGPT。现在就只能去在他的这个候选里面去选。那么使用插件逻辑其实是类似的。所以当function coding这个能力在chat API释放出来之后，其实很多人都会发现，包括我们后最后一趴也会去讲。
	就这个能力开放出来之后，其实GPT的plug in就变成了一个随处不在的一个状态了。然后跟南迁也能结合的更紧密了。因为它就不只是说我只能在这个ChatGPT的聊天对话框里去使用，而是说我能在任意一个地方去使用。包括我们那天看到在pattern notebook里面也能用。那在这儿我们能看到在它的官方的这个bug in的使用场景里，它会有用。
	这个现在我们都懂了，这个叫assistant message对吧？就是用这个ChatGPT的assistant的这个角色回复里面，它会去判断是否要使用。那这里因为我们没有发布，也没有去做这个authorization，所以他这儿就写的是一个使用了一个unknown的一个plain。如果我们把这些信息都填好，其实它会告诉你这里是使用的什么样的一些plugging in的信息，这里都会有。
	我们在实际使用过程当中，就跟我们用这个天气的一样，比如说我在问我有哪些to do，这个to do也是一个关键的。这个词在我们待会儿介绍里面会提，我有哪些to do项。这个突突项的里面其实就像一个记事本。一样咱们日常工作的时候也会有这样的一些需求。就我有哪些待办事项我记不住。有的人会建一个日历，建一个日程。
	在这个场景里面，它会用插件去调用一下，就针对你这个用户，我有哪些事情要做。现在因为我是刚刚开启这样的一个对话，所以他会告诉你，你没有任何事情需要去完成。但是你可以去让他添加一些内容，就比如说我们跟现有的一些像这个story这个小度之类的语音助手的时候，你就可以让他给你添加日程。
	这个是一个非常典型的一个使用场景。你比如说我这里告诉他明天十点提醒我开会，然后我们的插件会被调用，然后他会告诉你添加了一个待办事项，这个待办事项就叫明天十点开会。比如说我们每周日都会上课，对吧，我就告诉他周日的晚上七点要上课，他也会给我添加一个待办事项，叫做周日晚上七点上课。然后这个时候我就会问他这都有什么安排？因为这个其实是基于我今天去询问的那今天是周二，还会从今天到这周日的一个安排。他也给了我这样的一个列表，就这周的安排是明天十点需要开会，那周日是19点上课。那这个时候我们可以再挑战他一下，就比如说明天是周几对，因为你这样的一个安排没有锁定具体的时间，只写一个明天是不够明确的那这个时候大家会发现，他其实没有调用我们的这个插件，他直接去做了一个简单的判断，告诉我们今天是几号，是星期几，所以明天是星期四。
	大家会发现其实ChatGPT4的这个回复，现在也越来越像我们之前演讲的，怎么样通过这个step by step去做思维链的这个事情。其实他现在回复他从这个回复的内容和结果来看，已经越来越把这个事儿内置在ChatGPT里面了。所以在群里有的同学在问，就是我们的这个思维链要怎么用？巴拉巴拉这一堆问题。
	首先我们之前学习的chat API，它就只是一个API，它调用的就是一个原生的大模型。这个大模型是需要咱们来使用这些技巧，才能够把这个问题的回复质量提升。但是ChatGPT它是一个应用，在这里大家一定要区分大语言模型和应用的区别。ChatGPT作为GPT3.5和GPT4的下游的应用，它自然会在它的这个应用层买了很多的优化。就包括我们这儿看到的关于这种prompt的优化，这肯定是ChatGPT的应用层去干的事情。包括对于一些敏感内容的过滤，也都在这儿去做了这样的一些设计。
	在这儿我们能看到一些思维链的应用，并且他没有去调用我们的插件。因为他判断出来明天是周几，这事儿跟我的日程安排是没有直接关系的那这个时候我们可以把这两个上下文一起甩给接下来的问答，这也是我们在chat API上面有教过大家的，怎么样通过这个上下文，通过这个messages去让我们的ChatGPT的回复质量更高。他把这个周四的这个信息给塞进来了，所以他的最新的这个待办事项就做了调。这虽然还是明天十点开会，但他做了这个注解，明天是周四，然后这周有什么安排，你看这个是空的，这个是为什么呢？
	这里就注意有一些同学在可能有些已经有预习的同学，使用这个OpenAI的这个quick star，就是这个待办事项的一个插件项目的时候，会遇到这样的问题。因为这样的一个项目它本身是帮你记你有哪些突出项的。但是当我去重启了我的这个项目之后，我再去问他这周有什么安排，他的待办事项列表是空的，这个是为什么呢？这个其实跟他本身的代码实现非常简单有关，待会儿我们看到这个代码的时候，会跟大家再详去解释这个问题。
	那具体开发一个插件要做什么样的一个步骤？刚刚我们讲到了一个简简单单代办事项，官方给了这个四个比较大的步骤，看起来特别的冗长繁复。其实我们细看一下，这个步骤里面只有第一步是跟开发直接相关的，后面三步其实都是一些偏使用ChatGPT的流程。所以我们待会儿会在实际的这个实战过程当中，跟大家讲后面几步要干什么。我们现在其实就只需要聚焦这个第一步，就我们插件开发真正开发的部分，就这第一步的这个部分就够了。
	第一部分就涉及到了这个插件开发里面的几个重要的文件定义和概念，这个是我们这节课最重要的内容，需要大家提高注意力去听。第一个就是说我们的ChatGPT的plugin这个插件。只要你是一个ChatGPT的插件，通常需要具备这三个重要的文件，负这三个不同的事情。
	中间的这个叫做这个插件的原数据的定义，或者我们叫做manifest这个文件。它其实就类似于我们很多做这个java开发也好，做GS的这个开发也好，或者说其他的应用开发也好，都会有一个文配置文件。这个文件是用来描述我们这个项目本身的那在这儿其实就是用来描述我们这个插件本身的。所以大家能看到它有一些关键的T，包括我们的这个schema的一个版本。然后会有一些这个名称，这个名称就是指我们这个插件叫什么，就比如说name for human叫to do list，这没有结完，它是no automation就没有去做健全的那这个就是我们待会儿在插件市场里面能看得到，我们这个插件的名称就叫to do list。那还会有一个name for model，这个是跟以往开发应用最大的一个不同，就是以前我们开发这个软件应用项目的时候，通常都只会有一个名字，然后一个描述。但是因为我们现在在同时给终端用户，就是同时在给user和这个大模型，就是我们的assistant在同时给他们俩去做交互，所以就会有两份定义。
	这个跟我们之前学function calling是很像的那这里我们也会有description for human和description for model一样的。就这个插件我们需要有一个描述。大家如果还记得我们according的话，当时也是有这个对应的一些内容的。那这里还有一个比较重要的authorization，就是我要不要做健全。目前我们这个不算是最核心的开发内容，我们先把它设置为不需要，这也是官方的设定。
	然后第二就是说这个API。API我们使用了这个open API的这个版本，也是我们左边这幅图待会会讲的。这个是OpenAI发布的一个API的规范，就类似于我们写function的时候，function要有几个重要的内容，这么一个意思。它有一个UIL，这UIL其实就指向了我们左边这份文件，然后还会有一些原数据信息。就比如说我这有一个插件，这个插件其实有一个logo，有一个图标在这会去写。包括会有一些开发者信息。比如说你要联系哪个开发者会留下一个邮箱，然后有一些合法合规文件的一些链接等等。所以整个AI plug in的节省文件是用来描是我们一个ChatGPT插件的一个原数据的一个定义文件。
	这个文件里面最重要的几个部分。第一个就是这个插件的一些原信息，名字描述logo，然后开发者信息等等等。第二个就是这个插件是否要健全，在这有一个off。第三个就是它的API，API的版本和UIL。因为OpenAI其实发布了很多的open API的版本。现在我们今天的课程里面用到的版本，也是他目前官方推荐的这个版本是3.0点点1，就我们左边看到的这个版本。
	现在我们就回到第二个重要的概念，就叫open API的定义。Open API大家可以完全去类比，我们在定义天预报那个函数的时候，我们定义了几个函数。包括我们去用function calling去实现了在circle light上面去执行这个circle语句，对吧？那当时我们设计了一个函数叫ask database，我名字没有记错的话，这个其实是一个意思。Open API也是希望通过这样一种类似的方式去定义出一个函数。这个函数是干嘛的呢？是告诉我们的ChatGPT，你有这么样的一个函数，或者说你有这么样的一个功能，这个功能它需要这里我们就看到左边这幅图，它需要干什么呢？它需要有一些对应的这个summary这个描述这个summary就是一句话总结你这个功能到底是干嘛的，差不多这么一个意思。
	那这里其实他会写这个，我们是有很多个方法，大家能看到这有我把它一些折叠起来了，或者这个get方法、post方法、delete方法，这个是待会儿我们会讲的。它最终会有一个服务去承载它。但是在这儿我们先把这个给大模型要交代的事情讲清楚。仔细看这一部分的这个定义，它是一个压缩文件。
	这个压秒文件的定义里面，其实除了刚刚我们说到的要一句话说清楚你这个功能是干嘛的之外，第二个就是说你还需不需要一些额外的参数，就跟我们之前讲这个方式的时候有提到。之前讲这个方向的时候有提到，我们需要有一些特定的参数。这个参数有名字，它是不是必要的，它是什么样的数据类型，在这一块其实都有定义。当然它schema下面有它的类型是不是必要的，require是true。然后这个参数用来干嘛的？比如说这里这个参数叫username，那那它这个参数的意义就是当前跟他聊天的这个用户的名称。
	就我们一个插件可以服务N个用户，对吧？就如果我们真的发布之后，甚至你没有发布，你可以共享转给其他的开发者，这个也是允许的。我印象中OpenAI应该是在没发布的这个插件里，允许最多共享给100位开发者去使用，然后去共同调试开发之类的那当前这个用户你也可以记下来，这个信息还挺重要的。
	然后同时，你还可以定义它的一些返回状态。比如说它返回成功的话，那么它是一个HTTP code 200。然后下面有一个内容的一个格式，就它最终是一个服务，后来承载这个函数就跟我们之前写的notebook有点不一样。
	之前我们的notebook那个function calling那一刻，其实是我们有一个notebook的界面。然后那个界面里面我们把那个book的界面有点跟现在的ChatGPT聊天的界面可以对应起来。然后在那个界面里面，我们在请求ChatGPT的这个chat API。然后这个chat API其实会给你一些回复的信息，所以其实有点倒过来的感觉。
	大家如果去想象一下这个过程的话，那么现在就变成了你直接在使用ChatGPT，由HIGPT来调用这些定义好的预定义好的这些函数这些功能。那么它它调用之后，其实这背后他调用的这个，比如说我们这儿要去get the list of to do，就是获取所有的待办事项的列表的时候，那背后还需要有一个真正干活的对吧？比如我们之前写访问这个circle light这个数据库的时候，我们写了一个真正的去执行这个circle light的这个方法。就当时我们建立了一个连接一个connection，那个connection要执行我们的这个ChatGPT，执行我们的chat API生成的这个circle le语句一样。那当时写的那个实际执行的函数，现在就变成了最最后面的第三部分。这些真正的服务接口它就不是一个本地执行了，而是要去调一个远端的服务，差不多就这么样一个完整的一个逻辑就算了。
	原数据的定义，左边去定义这些抽象的告诉ChatGPT你有什么能力的函数，最右边是真正完成这些服务的一个接口的定义。那真正完成这些服务的接口跟我们左边的这个open API又是一个一一对应的关系。在function calling里面，我们是通过直接去调那个函数，就由我们自己人手动来指定的。但是在plan in里面，他用了一个特定的open API的规范，就是在哪里呢？在我们这儿大家看可以看到我们这下面有一个叫做path的这个UIL下面有一个path，然后这个pass其实是紧接着这个上面的UIL。要的大家可以理解成，我我我之前有了解我们的有些同学是没有web开发经验的。大家可以简单理解成，之前的notebook的开发，我们是在一个notebook的聊那个界面里面，然后我们去直接执行，都是本地执行，都在内存里。但现在变成了ChatGPT是一个客户端。
	然后你最后提起来的这个plug in的服务是一个服务端。我们的ChatGPT在客户端这边就要指定清楚，我要调服务端的哪个具体的接口。那怎么指定呢？首先要指定它的UIL和UIL的前缀，这个UIL这其实就是你那个服务端的host就比如说我们现在是起在本地的5003端口或者任意端口都可以，那岂在这个端口上，那其在这个端口上之后，它下面有一个具体的API的UIL，就通过这样的一个方式。
	这里还有一个细节，就是大家能看到这个UIL是通过5003这个host然后紧接着to do s，这里有一个username，但这个the name其实是一个path的，这个就是在我们这个UIL的路径里面的一个参数。所以在这儿有一个细节，就我们的parameters in，就是它在哪儿，相当于我这个username，这个参数是从哪取的？是从pass里面取的，就从这取的，但除了pass以外也可以从别的地方取。我们在天气预报那个插件里面，我们就会讲除了pass以外，本来就可以从各种各样的地方去取咱们的这个参数，对吧？OK那么下面类似的我能够获取这个列表，当然也能够去增加我的待办事项，也能够删除我的待办事项，就跟刚才演示的一样。
	然后最后跟这个这边对应起来，还有一个最关键的点，就是我这边都定义好了，我怎么去调用它了。但是我返回的结果，我们之前有一个困扰，我返回的结果能不能规范化？就我调用了这个天气也好，我调用了各种东西也好，这个玩意儿的结果能不能尽可能把它输出的规范化一点。
	尝试做了一个什么事情呢？就是我们的ChatGPT定义了一个open API。这个open API里面定义了一个schema，这个schema其实就是对我们返回结果也有一个描述。就在我们最下角这个地方有一个components，在components这边有一个get to do的这个response，如果能看见的话，这里有一个get to do response。这个其实是跟我们上面有做有关联关系，待会儿我们看实际代码的时候能对应起来。OK那我们就实际的来操练一下这个样例项目，其实并不复杂。
	先把下半节课要讲的这个天气预报的给关掉。
	这个是咱们的OpenAI的课程项目。然后在课程项目里面，这个课程项目里面，其实我们这部分代码还没有完全传上来。待会会结束之后，我们就把这个课程的插件的部分传上来。大家能看到其实这个路径是在OpenAI的这个quick star，也是咱们这个项目里面，其实是有一个。
	这样给。
	大家看一下。
	在我们的这个项目里面，新加了一个目录，叫做ChatGPT的plug in。里面有两个插件，一个叫to do list，一个叫我们的天气预报，那就对应着这节课的两个的重要工作，在这个顶级目录下大家应该在这儿也能看到。好，我们现在进到这个插件里面，先看这个to do list。这个是我们刚刚讲到的原数据的定义我们把这个原数据定义里面最关键的几个点再跟大家稍微赘述一下。一个是不使用这个健全，一个是定义好了我们这个UIL这个open API的这个URL，它把它放在哪个URLURL里面。然后使用的这个API的规范类型是open API，然后有一些原数据，包括像这个logo，contact email之类的等等。
	好，第二部是我们在这儿能看见有一个OpenAI的API的压面文件。这个文件是首先这个项目是完全从官方项目拿下来的，没有做任何改动。所以大家自己可以去做很多的修改和调整，这都没有问题。这里有做一些基础的定义。
	我们刚刚看到的截图，然后我们的这个缩下来，然后我们刚刚讲到这个components和咱们的上面的这段代码是怎么关联起来的。大家仔细去看，这里有一个叫get to do的response，这边已经高亮出来了。就通过最下面的这个部分，我们首先需要对返回结果做规范化，这个是我们的一个需求。那这个需求怎么样去被OpenAI的API去满足和定义呢？通过response的定义来完成。
	这个在之前我们用function calling的之后，没有特别好的方式。但是在ChatGPT这里做了这样的处理，是因为它本身就不再是一个本地的函数调用了，而是变成了一个远端的外部服务API接口的调用。所以它对于一个API远程的调用，在这儿就是一个HTTP的调用。那对于这个调用，它是需要做一些规范化的约束的。就比如说这个HTTP的状态码200的情况下，它认为是一个OK的返回。然后里面包含的这个内容，这个接口返回的内容类型是一个Jason。然后它的schemer就是它这个js里面的这个schemer应该满足一些什么样的定义？
	这儿有一个关联关系，这个其实就相当于一个链接，一个link一样。这个层级关系其实就对应着这里的一个层级关系。在我们上一节课讲OpenAI的translator的时候，我们曾经用过一个压mail的加载器。我不知道大家还有没有印象，就通过这个压mail加载器，通过这个加载器我们就能直接读取压缩文件。所以整个压mail通常是符合这样的一种层级关系表达的。
	所以这里的意思就是说我们去获取代办列表的这样的一个抽象出来的一个功能，它的接口返回用这样的一个方式来做约束和定义。相当于我们拿到了一个结果，这个结果不会直接甩给我们的终端用户，而是通过这样的一个处理再给到我们的用户，在那个ChatGPT的聊天对话框里再显示给他。所以这个后处理的部分在这儿去做了定义，那这一部分其实跟我们方程空间也好，跟这儿也好都很像。这种偏我们认为叫没这个open API的定义，或者说这种函数的定义。但它不是函数的这个实现，是函数的这种抽象定义。其实大家写多了之后就会发现，套路也是类似的。在这儿它定义了我们返回最终的是一个列表，那这个列表里面的每一个元素是一个字符串。
	然后这个列表本身是待办事项的列表，the list of string，然后类似的还有两个接口，一个是添加待办事项，它叫add a to do to the list，就加一个待办事项进去。这个就有一个add to do request。对应的这里的一个add to do request，那有一个要求就是必须要给一个do，然后类似的这个删除就必须要给一个to do的index，这个是类似的，到时候我们就不再展开了。这个是对于request的一个定义，我不知道大家有没有注意到这个细节，就是我们在request body里面一样可以去做这个定义。这个时间关系我们就不再细讲了。就是我们刚刚讲的对response可以做后处理，那对于输入也可以做前处理，这里跟我们的方程也是完全类似的。
	好，第三部分就是我们的怎么样去承接这个实现，就我们刚刚看到那个定义了各种各样抽象的函数，然后有路径对吧？那怎么样去实现呢？通过这里的这个main点PUI，也就是我们的to do list这么一个ChatGPT插件的启动文件，这个命令PY大家应该都执行过几次了，对吧？那它其实通常作为我们python项目的一个主启动文件。这样的一个文件里面定义了很多响应这些API给我们具体的这个UIL的这样的一些装饰器，这装饰器就是用来回应我们前面定义的那三个函数，分别是对应着我们的get，就是我们获取整个待办事项的列表。我们添加一个待办事项post delete，就删除一个待办事项列表当中的一个，那这三个就对应着前面的三个函数，可以把它拖过来给大家做一个对应，这里是一一对应的。
	好，然后它跟使用这个，首先这个count是一个，后面也会去讲。这个count是一个python的用来做web开发的一个微服务的一个框架。这个框架其实就是能帮大家快速的把自己的代码变成一个web服务。就这部分关于web开发的基础知识，大家如果不太了解的，可以回头找我们的班主任也好，找其他助教老师也好，我们应该是有赠送一些python的基础课程和外部开发课程的。所以我就不占用太多的时间去讲外部开发了。
	简单理解一下，就这里跟它是一一对应的关系。然后通过这个court的框架，我们能够把这样的一个函数去响应我们对应的一个API，这里其实这个函数实现我没有去做太多的注释，也比较简单。他自己定义了一个python的字典，就是我们的待办事项的列表。然后我们开始有提到，我们会针对每个用户都去存。相当于每一个用户有一个自己的待办事项的列表，用这个python的字典存下来的。然后我们刚刚在课件里面有看到，就是我们了天聊完之后，再次去提问我有什么待办事项的时候，他不记得了，这个是为什么呢？这就在于我们整个这样的一个plug in的服务端，其实它并没有做持久化，持久化这个是个基础概念，相当于我们只是在内存里面存下了这个to do这里应该也有做这个一行很重要注释，官方有写，没有持久化。这个时候如果我们重启了这个python的这个服务端，我们现在右边看到这个门诊PY这个文件的话，那么自然重启起来之后，这个to do是空的，什么都没有，还没有去把以前的这个结果存下来。
	所以就会出现这样的一个情况，这个是很正常的。那这里也给大家留下了空间，如果我们要去开发一个插件，核心先是把插件当成一个外部服务，就你是还借这个愿景对吧？通过ChatGPT的能力，以插件的形式赋能千行百业。那你这个行业里面的应用特点，以插件的这样的一个形态变成了一个服务。这个服务怎么样让ChatGPT明确知道什么时候该调用？你在function calling里面我们摸到了一些门道，在这儿可以复用这个能力，然后我们待会儿的这个天气的预报的这个插件，也会去直接给大家看怎么样把它们连接起来，所以就是这么样的一个组合方式。好，那我们看一下实际怎么样去启动这样的一个插件。
	启动起来了，启动起来之后，这里打出了一些日志第一个就是说我们这有写它是一个court APP，这个是一个python的微服框架。刚才我讲然后又他这边还有一些提示信息，我们这就不再赘述了。这个框架的知识大家可以回头再了解。那我们就实际对比着来看一看会发生什么样的一些稍等。
	浏览器？
	刚刚在这被一起关掉了。
	稍等一下，回到这个ChatGPT的界面里面来。
	我们把它缩到旁边。
	大家现在能看见这个ChatGPT的这个浏览器界面吗？
	可以看见对吧？好，对这个第一次自己推流出来一点小的意外。好，那我们就看一下，首先这个界面，只要有这个ChatGPT的插件访问权限的同学，应该跟我长得是一样的，是这样的一个访问界面。
	这个是我们待会儿会看到已经开发好的这个天气预测的这个插件，然后我们进到这个插件市场。在插件市场里面我们可以看到上面是这个市场里面的一些已经有的发布了的内容。然后我们在下面这这下面有一个开发你自己的插件，develop your own发给。在这儿其实我们会发现它会让你输一个豆面。这个意思就是我们刚刚启动的这个服务。大家还记得端口吗？应该是500几，5003，我们把这两个窗口同时放在这儿，今天这个课应该会经常有这样的一个状况。把拉上来。
	好，我们可以看到右边是我们的服务端，左边其实相当于就是我们的客户端。我清楚这个看的清楚吗？大家能看见我们的左右应该都看得清楚，对吧？看得清楚打一个一，我确定这个字体的大小是合适的。好，那我们继续。这里能看到他发现了一个bug，in就我们的ChatGPT发现了一个plug in，这个plug in其实就是我们刚刚启动的这个plug in，因为我们输入了这个host的5003，他发现了这样的一个plug in，然后你可以把这个local host flag in给它装上去。
	然后这个地方有一个有一段话叫manage your to do list，you can add, remove and view your, 那这个，就跟我们刚刚看到的这文件里面的定义是一模一样的。在这个部分，大家能看到manage your to do list，对吧？然后you can add巴拉巴拉，这是给人看的，在discretion for human里面，然后还有这个name human to do list no，包括它的logo这样一个文件，这个logo文件就是我们这儿放的这个logo的文件，这就不再赘述了。我们就把它安装起来，它是需要有一个安装的过程，因为它是一个服务，对吧？那我们去点这个安装。好，安装之后，大家能看到这里就有一个下拉框，对吧？这个插件里面，然后你可以选择你当前新，因为它是要新启动一轮对话，新起一个聊天的窗口，里面要加载哪些插件，它是支持你同时使用多个插件的。那这个是大家可以去复合的去使用。那这里我们先简单选择一下，就用这个标准的这个to do list的插件，然后选择它，这里会有这个对应的logo，你比如说现在我们来实测一下。
	把这个收起来。大家能看到它去启动了这样的一个using to do list插件，然后右边这接收到了一些请求。大家有没有看到，这里刚刚跳出来了一个get to do user，这里能看到这是一个新的请求，由我们这左边这个ChatGPT的这个聊天窗口发过来的，这个是很常见的一个客户端的请求，服务端接到请求的一个日志打印。好，那么这个时候假设我们说这个。
	比如说。
	你提了这么一句话，对吧？正常的如果我们没有插件的状态，大家可以去试验一下去自己去手动试验一下。如果我们没有加载一个插件的话，它会回复你什么样的这个事情。然后我们使用插件之后，它其实会去判断，我们其实是定义了这么一个open API。大家刚刚看到它触发了一个post请求，对吧？在HTTP的这个在restful的这种API定义里面，post通常是新新增加一个事物，那这那post里面就写了一个add to do to the list，然后add to do to the list它还会给你确认，明天中午12点和助教老师吃饭，这个是重新给你描述了一遍，重点确认的时间，以及这个事情。比如说现在我们再去问他。
	大家会看到他这同样调用的这个get to those user代办事项对吧？这个时候我们可以多添加几个。
	比如说这周六有一个建筑设计博览会在上海，我已经报名了，大家提醒我。
	它依然可以去识别出来，就不管你用这个比较规范的语言，还是其他语言，它都能记得住。
	好。
	并且大家这里有一个很有意思的现象，我不知道大家有没有去注意到，弹出了两个used，这个调用了两次，为什么会这样？有没有同学能抢答？为什么会弹出两个？这事居然还需要两次，对吧？为什么？因为这里有写对吧？And a速度一次就只能添加一个代办给的这个函数，就这么个功能。所以当它ChatGPT识别到这是一个提醒的事情之后，他会去看你到底要有什么突出加到list里面。
	那这个是一条一条调用一次一条调用一次对吧？已经开添加了我的待办事项，并且添加了什么返回什么，而不是返回你所有的待办事项。这些东西都是在哪定义的，都是在这儿定义对吧？
	在我们的open API里大家去细看一下，这边有写user name，在我们的username，就是我这个用户，然后我这个用户里面需要添加一个to do调用一次，在request里面对request有一个schema的要求，schema的要求在把它收起来方便大家咋可能。Add to do的request，必须要有一个to do，并且也只有一个to do这个to do要添加到我们的to do list里面。好，现在我们再去看我有哪些待办事项的时候，他其实已经有三条了，对吧？
	OK. 到这儿为止，其实我们的这些功能基本上都跟这儿做了一次对齐。那我们再来看一下，就是这个函数里面的实现，是把所有的这些待办事项其实是存在了这样的一个字典里面。这个字典其实是没有做持久化的。所以如果大家不小心作为一个服务，经常会有这个稳定性问题需要处理，对吧？就比如说遇到了一个人，他直接给你停掉了，那这个服务就没了，这其实是不感知的。大家发现没有？就是我们客户端其实是不感知我这边的这个plug in的服务已经关掉了，这里都没有任何的操作。那这个时候我们会假设我们仍然去对他进行访问比如说我们再添加一个事情。
	我们看它会发生什么样的事情，他会去继续尝试调用这样的一个插件，那能不能调用成功呢？理论上来说这个服务已经停掉了，对吧？
	我们能看到这里是他传给我们open IAPI这边要求的一些内容。我们这里有要求，他需要有to do。然后我们的to do是在request body的schema里面严格有要求，是一个required的一个参数。然后在我们的这个post里面，我们的函数定义里面，我们的接口定义里面也有要求。我们的user name也是一个必要的要求，这个user name直接就取了。这个user没有取我的这个实际名字，他也没有去做这个健全，他会一直在这儿等待这个地方出现的这个可能是等待很长时间之后，他终于告诉你这个东西挂掉了，那我们重新把它启动起来。
	看看能不能接收到字的请求。在在我自己开发这个插件的过程当中，我发现其实OpenAI的这个插件对接的这个服务，就相当于用ChatGPT来调我们后端插件的这个动，这个时还是有一些不可复现的一些很奇怪的问题。就比如说我今天在实现这个天气预报插件的过程当中会发现他自己会有一些缓存没有清理的问题。只有你重新换了新的端口，它才能够正确的去进行一些加载。那就包括这里，其实理论上正常的一个客户端请求不应该是这样的一种处理方式，过于粗，一直在做请求，没有这个time out或者说这个time out过长。那这个时候我们直接选择这个regenerate，重新去做一次请求。好，他收到了这个重新的请求。周五参加专业分组，理论上我们按照之前的这个正常逻辑应该有四条，对吧？但其实大家应该也能猜到，他应该只会给你一条记录啊。
	对，所以这个就提醒很多同学，如果我们想要在插件开发，在t GPT插件开发这个事儿上面做的比较成熟的话，其实大语言模型是很薄的一层。它是提体现大语言模型语义理解智慧的这一面就是它有一个很智能的一个聊天机器人。同时它能跟你自己的业务去做对接。但是你的业务做完对接之后，你的这些数据要怎么存下来，持久好的存下来，以及你下一次重新启动之后，你的这个服务要怎么样变得非常稳定。这事儿其实ChatGPT是完全不管的这跟你开发任意一个外部服务都是完全相同的。你需要去做负载均衡，你需要去做这个热数据的一些处理。比如说你需要去做缓存，有一些高频访问的数据，你可能直接放在硬盘存储里，或者放在数据库里都是不够的，响应太慢了。
	我们在待会儿的这个天气预报的插件里面，我还会去写每一次请求花多少时间。正常我们在传统的web应用里面，就大家聊你的请求时长都是以毫秒作为单位的。但是到了拆GPT插件这个领域之后，我发现大家其实宽容度变高了。因为它很智慧对吧？它它有很多的智能性的东西，大家都容忍它能在5到10秒这样的一个时延，或者说这个响应时间去做回复。但是这也只是一个简单逻辑的处理。假设我们进进阶篇里面，也会用南茜去做多次大模型的调用。
	那它一次请求可能就会等待几十秒或者一分钟。这个对于一个用户的最终体验来说是非常差的，尤其是我们现在建了这么多的大语言模型之后，你对于它的智慧的、智能的这一点的容忍度在逐渐的降低。你就是希望它越来越快。在越来越快的过程当中，我们传统的这些提升服务稳定性、提升服务质量、提升响应速度的这些技巧，这些知识都能派上用场。就是在我们右边这个VS code的这个界面里面看到的这个服务端能去做大量的工作。并且从这个视角来看，你也会发现开发一个ChatGPT的插件用什么语言不重要了，对吧？
	如果仔细再来回味一下这个简单的样例项目的话，其实我们用任何一门语言，只要提供了标准的HTTP的接口。然后我们的这个接口的定义跟这边open API的定义是能对上的，那么就不会有任何的问题。因为它它就只是向你发送一个请求，然后发到哪儿去，是在我们去定义这个插件的时候，在这个地方我们去新建一个对话，在插入这个插件的时候，在这儿的时候就已经明确写了，所以你需要整明白的就是说这个地方的域名，你的服务一定要做的足够稳健，并且什么语言都行。只要你能把这个服务的接口按照我们的open API的要求填好。
	那意思就是说UIL要搞对参数，要搞对哪些参数是必要的，参数是可选的，哪些参数是在这个UIL里面，哪些参数是在body里面，哪些参数是一次。比如说这个请求这里有一个添加一个待办项，哪些是一次要只能加一个的那是不是可以写一个post的请求？是add一批，那当然可以写。那你只是需要写一个新的API的接口，在main点PUI里面定义出来。比如说它可能叫做post add to do对吧，或者说add a list of to do之类的。
	这个其实就是一个完整的ChatGPT的一个开发流程，其实是覆盖了。但是你说能不能在上面叠加各种各样的，当然可以。比如说我们刚刚有看到在AI的pub in里面有这个off，你可以去做健全，你还可以去做各种各样其他服务端的花活都能去完成。因为简单来说，ChatGPT就只是一个调用你服务的客户端。它唯一的不同在于他来决定什么时候调用你，而不是说你来决定，而不是你能操纵这个客户端，你想在任意时刻调用都行，唯一的区别就在这。
	好，然后我们再最后介绍一下这个和这个开发者的工具。就在这个设置里面，就我们刚刚看到在你的用户设置里面，是有一个open的plug in的开发者工具的那这个开发者工具打开之后，你是能看到很多的有效信息的，并且可以通过这个去了解这个OpenAI的API定义。就比如说我们这儿看到，这里有一个get the list of to do，对吧？就对应着我们这儿定义好的，get the list of to do. 
	然后这个玩意儿是定义成啥样的呢？它定义了这个get to do这么一个，你可以先理解成定义成了这样一个函数，而这个函数需要一个必要的参数叫user name。然后类似的我们下面有添加代办，我们有删除代办。他们都可以在这个地方去做查看，包括它的必要的参数是否定义正确，然后它自己本身是一个什么样的类型。
	然后这里还有一个name space to do，通过这个name space你会发现它其实还可以有多个name space。多个naming space无非就是对应着更复杂的场景。比如说多个ChatGPT的gain都在这儿展现的时候，通过name space能区分出来。对，包括它的manifest，就我们定义的AI plug in，Jason在这儿也都能看得见，定义的是什么样的一些内容。我们的OpenAI的这个spec在这也都能看到，那就对应着我们这儿的两个文件，都能在这得到对应的查看，这个是它的一个开发的工具，我们也能够去这儿手动刷新这个blog in。那他就会去重新获取一遍。大家看他其实发送了两个请求，去重新获取了新的AI plug in Jason和我们的OpenAI的这个open API，那就会重新去获取这两个人，整个开发者工具也是一个非常实用的一个工具。好，这个其实是一个样例项目就是这样的一些流程和内容，看看大家到这儿有没有什么问题，我们简单五分钟的时间提问，接着我们就开始去把这个天气预报这事儿给它完整的端到端，做成一个插件。
	我们挑一些问题，到9.05，我们正式开始下半节课程。有个同学问我的setting里面没有plug in的DEV选项，是要在其他地方开启吗？有plug in没有DEV在这个地方大家注意一下stating。
	然后有一个data feature，就是在这个是一个软件工程软件开发领域的一个概念。就是我们对于功能特性是可以分级别的，这个叫语义化版本命名方法。对，叫sensitive version 2.0的这些命名方法里面，通常把这个贝塔的feature定义成这个feature的功能，定义范围已经确定了，通常这个功能不会再大改了。但是这个功能本身的稳定性还在调整，所以它不会面向所有的人开发，所以会放到这个beta的feature里面。所以大家能看到这里放了三个他认为这个功能是什么，已经不会再改了的一些feature。
	包括之前在群里有人提到这个customer instruction。对，然后这个是bug in这个是code interpreter，你打开之后自然就会有了。对，包括这个数据协议，你可以把你之前跟他聊天记录导出出来，然后你能够去分享你的这个跟ChatGPT的聊天记录。对，然后有了之后这个general这就有了，就可以了。
	有个同学问老师能不能画一下ChatGPT和自己的plug in大语言模型GPT4GPT3之间的关系汇集一下。可以这个可以安排我们在南迁的时候准备是讲这个关系的对，首先ChatGPT和自己的plug in这个描述是不是很准确的？就简单来说，我今天一直在强调ChatGPT是一个客户端，plug in是你自己的服务端。现在看起来像是自己的，是因为他没有把它变成一个可以对外访问的服务，是一个本地的local host的一个服务，你也可以直接去拆GPT去调用一些已经发布出去的，通过域名访问的服务。这样你就会感觉不是，这plug in不是ChatGPT的了。对，然后有个同学问ChatGPT怎么知道要调用哪个插件？大家请回到function calling那一节课去，在那节课就已经埋下了一个种子。
	告诉大家，现在的大语言应用的开发一个很重要的点就是不仅要写代码，并且要跟大模型一起写代码。跟大模型一起写代码就是告诉大模型你有什么样的功能可以去借鉴去用。就类似于我们方里面的函数定义以及彻底的open API，我们今天花了很长时间讲这个open API，就是目的告诉他，就相当于open API是你跟大语言模型沟通的一种普通话。这个普通话里面有一些标准化的套路，去告诉大模型你有什么样的能力。
	所以整个open API每一个这里的这个呃它下面这样的一个方法都对应着你自己的一个API。就是你把你的API，我们又来讲这个概念，你现在不仅要当开发者，你也是一个产品经理。那作为一个产品经理，你现在有什么样的能力，你能不能讲清楚？如果你能讲清楚，那大模型就能知道在什么时候调用你。
	还有同学问服务器是要自己申请云服务吗？这个都可以。你哪怕用你自己家里的笔记本也可以，只要保证你能够让这个访问到，对吧？Plug in怎么上线的对，plug in是需要申请的，这个我们待会会放在最后，这个是属于非开发的部分，我们有讲这个开发四个步骤对吧？那非开发的部分我们就后面再讲，也不是一个技术上的事儿。插件市场那里没有开启插件开发的选项，没有太看懂这个意思。
	还有同学问多个插件可以自主切换，据我了解不可以。这个是应该是在你开启这个对话的时候就已经确定了。大家可以注意看这儿，这是无法编辑的，就相当于是一个预定义的一个操作。除非你先开启一个chat，不然这个chat能使用什么插件就已经预定好了。无非是说这个插件可能会这个服务访问不到，那么它可能需要重新访问，但不能再额外调整别的插件了。那如果你新起一个聊天记录，你是可以选不同的插件的。
	还是不理解plug in那个Jason里面的for user和for model是干啥的。再说一遍。区别是什么？区别就是这个for human就给人看的，所以我们在插件市场里看到的都是for human的内容。那for model是干嘛的？那个给model看的，因为我们已经花了很多精力在讲这个model是什么了，model就是我们的ChatGPT，就是我们的GPT模型，就ChatGPT这个应用，这些都是我们的for human的内容，对吧？包括我们的开发者信息，大家可以看到这些应用。这是它跳过去的这就是他的lego info，然后以及他的email，我这就不点了，这个是一个email address，这是他的email。
	有个同学问，继续问，他有customer instruction，有plug in，有code interpreter，就是没有plug in。那可能这个pluggin的开发就是一个需要额外申请的权限，这也是为什么我说选修就是这么个意思。对，如果咱们是开源爱好者，然后咱们就经常做开源项目，然后又给这个OKI的官方twitter什么的有过一些互动，很快就会拿到这个权限。我记得我应该是三四个月前，三个月前，五月份的时候拿到这个权限的对，大家多玩一玩开源项目，然后去Q1Q这个OpenAI的团队函数定义是尽量用英文描述吗？
	如果你指的是这个open API的定义的话，那肯定是的。Open API怎么用GPT生成？Open API只是一种规范样式，所以核心是你要用open API定义什么东西，对吧？就是这个open API的这个普通话本身并不难，关键是你要用普通话讲什么内容。因为学一个样式是GPT最擅长的，但是那个样式就这个value是我们看这儿这个value本身是更难的。让他写成这样的压秒格式，他马上就能写出来了。对。
	什么场景用function call，什么时候用plain？好问题，这个我们放在待会儿最后一部分跟大家讲，这个同学提个好问题。
	有同学问服务放在本地local host为什么能够被GPT调用？你可以理解成这里有一个APIK，就是你要知道你是这个插件的开发者的一个身份在用这个。我再跟大家讲一下这个逻辑，就是你是一个插件的开发者，所以你自然就有你的你的APIK，然后有你的这个身份鉴定。所以我这台机器就右边这个服务端是能证明我的身份的，就是我当前登录的这个用户，就我现在登的这个XGP的用户。所以他的low cost自然就是直接去访问的这里了。对。
	GPT不能自动切换插件，感觉还不如function calling更有意义，能这样理解吗？我们待会儿再聊这个问题。
	然后。然后我们就接着下一下半节课了，待会再回答问题。
	好，那我们来实际看一看怎么把之前我们留的一个家庭作业，既把它的上一次的作业做完就我们能调用一个第三方的平台去完成它的实际的天气预报的查询。同时还能把它变成一个ChatGPT的插件，首先我们就对着开始说的最最重最重要的那三个文件来聊。第一个就是我们的AI plug in节省，就是我们这个插件的原数据的定义，我们这儿定义了一些关键内容，比如说这个插件的名称叫weather forecast，就是这个天气预报。所以for model就是一个写的比较简单粗糙了。这里的原数据信息for model确实它意义没有open API那么大，你可以理解成是一些简单的信息。至于这个原AI它给你节省这些元素信息里面的description，ChatGPT会怎么样去使用，我也没有找到特别明确的说明，核心还是那个open API的定义比较关键。
	好，那接着下面的地方是不用怎么变化的，你可以理解成我们现在为了简便还是没有去做这个健全。然后使用了同样版本的open API的定义，唯一的不同是我们这个服务起在了5002的端口，然后稍微修改了一下，加了一个联系人，这些东西大家都是到时候需要去修改的。然后如果你这个服务真的要发布出去，从合规性的角度，你一定要去填写这个legal info UIL，不然你是申请审核通过不了的。
	然后这个description里面给人看的就是这一个全球的天气预报查询。你可以查询当前的和未来的天气。在任何的城市，甚至更细的街道，我们都能做到。
	然后第二个就是说它的open API要定义什么？大家还记得之前function calling课，那那那节课里面有定义两个函数。一个函数叫get current weather，需要传一个city，传一个format，format就是是摄氏度还是华氏度，它跟我们传是一样的，这是我们为了简化，我们就先把它拿掉了，你加上也都OK的。第二个就是说get n days weather forecast，就是几天之后的天气是什么样的，这是我们又定义了它的这个AAPI的定义。
	好，那我们细看一下这两部分跟刚刚那个有什么不同。首先路径这俩都是get方法，都是我们rest for里面的一些get请求，就是获取信息的。它不会对我们最终的这个，如果我们把它当成一个restful的一个接口的话，它对于它的最终的这个结果，服务端的这些数据不会有任何变化。OK然后get weather current，这个命名写的比较粗糙，标准的restful定义不太会以这样的方式来命名，但这是为了让大家能理解，我们就按这样的方式先写的这个UI，whether current和这个weather forecast分别对应着这两个不同的API。然后这俩不同的API有不同的参数，比如说这个current只需要传city就够了，那对于我们的这个预测，当然还需要传一个number days，就是到底要预测几天后的对吧？然后我们接下来在这个response里面也有对应的一些定义，就比如说返回当前的这个城市的天气和未来几天的天气。OK没事，我们就跳过跟刚刚一样的，这个也很简单接着就是我们的定义，就怎么样去处理这个请求，左边这部分其实刚刚没有详细讲，大家细看的话，在我们刚刚去展示这个开发者工具的时候，有一个这个refresh，pug in就刷新这个plug in，其实就刷新这个服务端，具体怎么刷新？
	它调用了几个请求，其中就有get这俩请求，一个是get这个AI play in Jason，一个是get open APIER秒这个天气预报的插件，我给大家添加了丰富的注释，因为这个大家肯定会动手去改去操作的，并且也留了一些可操作空间。待会儿我们看实战的时候，可以给大家讲哪些地方可操作。在这儿你看我们首先看到这有一个获取与原数据信息的这么一个接口。这接口其实干的事儿就是我们去获取了这个主机名。主机名就是我们现在这个local host，然后我们打开了一个本地的文件，这个本地的文件就是我启动这个插件的文件，然后放在这个well known下面。这个是他官方推荐的一个目录，自己造的一个目录。然后下面有一个原数据的文件，把这个文件打开，然后读进去，读进去之后，把这个作为我们ChatGPT来请求我们的原数据的返回。然后用的是text Jason这么一种多媒体的类型，作为这个序列化的方式。然后下面是去获取它的open API。
	就假设这两个文件变了，我们在刚刚的开发的工具里面点刷新之后，它还能获取到不需要我们再去重新启动一个新的聊天的这个new chat，这是用来干这俩事儿的，操作也都是一样，唯一不同是他们的序列化方式，一个是这个Jason，一个是这个压缩，上面是获取这个logo，我们的logo其实也是本地的一个文件。然后这个本地文件，其实就是去获取我们这里有一个天气预报的logo，然后这个文件已经提前传上去了，他拿到之后也把这个返回过去，这些都是一些基础的客户端服务端做web开发的一些内容，这些包括这个main tape大家去了解就行了，不复杂。接着对应的右边是我们定义的两个函数，一个叫get current weather，一个叫get n day weather forecast。
	那这两个干嘛的？第一个是获取当前这个城市的天气的一个情况，我们这儿写了一个简单的处理。第一它它其实会去获取到我们的这个city，这儿就跟刚刚有一些不同。我不知道大家发现没有，刚刚我们是在直接在这儿去获取了to two，对吧？直接在这个里面去获取了to do。因为它是一个UIL的一个参数，就是相当于它是写在这儿的，就我们刚刚那个user name，大家还记得吗？
	故意把这个参数的形式获取方式做了一个调整，就照顾一下这个不是有外部开发经验的同学，就是我们客户端发给服务端的请求，有很多种方式都能埋参数，有的是埋在这个路径里的，埋在这pass里面。所以刚刚的那个案例它是埋了一个username在这儿，你也可以把它埋到别的地方。比如说这儿埋到这个arguments里面，那那它其实就相当于能从这个key，这个city这个key里面去取出来，这个arx里面取出来，取出来之后就获得了这个城市的名称。
	因为我们待会儿会演示的，然后实现了一个内部的方法，get coming to weather，因为大家如果了解的话，待会我们会讲真正的天气查询的平台，因为这城市范围太大了，通常用城市去查天气是不太靠谱的。那要么就是你把它转换成一个经纬度，一个具体的地球上面的一个坐标。经纬度确定之后，能确定这个地球上的一个点POI，然后那可以。
	还有一种方式就是像国内的一些平台，它会去给城市给区域做编码。他要查询一个天气的时候，也是在区域这个级别，比如说一个特定的区，而不是这个大的城市。因为城市范围太大了，天气不同的区可能都会有变化。在区域这个范围内，你提供一个区域编码，它是能够去查询到当前的天气状况或者未来的天气预测的。所以我们内部的这个实现就get current weather，会去做这么一个事情，把我们的一个城市的名称变成一个城市的编码，甚至区域的编码。然后丢给我们的第三方平台，第三方平台把查询的结果处理好之后，我们再把这个结果还给我们的ChatGPT，就是我们的这个court response做一个序列化。返回状态是200，这个也符合刚刚我们的open API定义对吧？返回状态是200，然后这里有写是一个我们的这个定义。
	好，那接着我们再看这个，下面这个也是类似的，就获取了一个city，但它额外获取了一个参数是number days。然后这个number of days我们希望它是一个整数类型，所以在这儿做了一个字符串到整型的一个转换。我会把这两个丢到一个内部实现的函数里面，叫get any weather forecast后去做处理。
	好，待会我们会实际去看怎么实现的那接着就是这个court，这里留了一页让大家能够去研究。它是一个python的一个web开发的一个框架，他提供了这个rest of the API，然后也能够去渲染和serve这个HTML，包括这个web talk，它也支持流失的这个返回。比如说我们要做实时聊天的应用，可能就是你一个一个往回返回巴拉巴拉的这些东西。大家如果要去研究python的这个研发的话，可以去看一看这个项目。当然你要用别的像flash或者浆果之类的python的框架也都可以，其他语言的话都可以。就只要你有一个web的框架，能够去变成一个web server，提供出这些API，让我们的ChatGPT能调用你就可以了。
	好，然后天气查询的这。这个平台我找了很多，本来是找了一个海外的平台。那我想一想可能国内的平台大家访问起来更方便，并且也是中文的语言的文档，也就最后用了高德的这个平台。然后我看有有的同学在完成家庭作业的时候，function calling的时候也用了这个平台。那我们待会儿也给大家看一下这个平台上面的一些文档介绍，我就没有把这个官网的文档也粘过来了。我们待会儿访问他的网站就好了。
	那这里其实他有写很关键的一个点，就是他一定要申请APIK的。所有大家做开发多了就会知道这种第三方平台，包括TIGPT这个GPT的模型，这个APIP是一定得自己悄悄保存好的。我看有一个同学提交到这个代码库里来了，这个很危险。虽然这个我相信可能已经处理了，如果没处理的话，一定得处理好。对，APIT是一定不要提交到这个代码库，这个是非常危险的一种操作。
	好，那我们就来实战看看这个天气预报的这事儿怎么能做成一个我们的插件。我们还是首先看这个开发者文档，左边这个是我把它稍微再放大一点，这个字体大小大家能看清楚吗？就左边我们的这个高德的开放平台这个文档。已经有同学在问这个API是不是免费的？巴拉巴拉的对，这个API它有提供免费的查询接口，大家也可以用别的平台。因为这个本身就只是一个第三方用来查天气的平台而已，并没有什么特别的好。然后这个平台里面应该是有写它的这个用量的可以。
	这里获取这个APIT，然后在这个开发指南里面有去讲怎么样去获取这个key，然后这个拼接HCP的UIL。如果咱们之前完全没有这个web开发的经验的话，看这个中文的文档应该还是比较能快速的去获取到这个怎么样去做的这么一个指导。好，然后我们重点关注的是这个天气查询，那天气查询的这个接口里面，这有一个服务量的一个使用限制。你点这儿，还有这个限制的说明。目前我们是个人的开发者认证，完全够我们去使用了，在这个里面有写它的这个用量，其中包括我们的什么地图类的，然后路径规划类的。
	我记得天气查询好像是一个。他这个文章挺怪的，我今天应该是有看到天气查询好像是有个10万次还是多少次的一个量是免费的。然后大家也没有去配置这个，这儿有大家能看到这儿有这有一个天气预报的用量，目前是采用了29次它的调用量上限一天是30万次。我没记错的话，对，一天可以调用30万次免费的这个天气查询，所以还是蛮便宜的。为什么这么便宜？其实也挺简单的，因为天气查询也不是一个实时需要去做计算的，它也就只是查了一下数据库，所以他成本挺低的对那么回到这个接口文档这来。
	去查询这个天气，其实它提供了两个重要的接口，其中一个是直接查询天气。在这儿我们看到它对参数有一个说明，其中这个东西叫城市编码。这儿其实就有两种方式来做这个事儿。一种是咱们可以把这个城市编码表下载下来，然后写到这个服务端的服务里。我们把这调成我们的天气预报的这个项目代码。用点心。
	好。
	我们把这个p to do的先给它关掉。
	好。大家可以看到我们在这儿其实是要去获取这个城市编码表的。因为这个城市编码表才是真正可以去用来查询天气的，在这个地方去做这个查询。但是我们在刚刚的设定里面，我们的用户肯定是不了了解城市编码表的。而且你跟人聊天聊这个编码表也没有意义，对吧？人是不太可能会这样去沟通的。所以这里其实额外有一个步骤，就是怎么把我们用户给到的这个CT也好，具体的街道地址也好，转换成一个城市编码。然后这个城市编码最终可以给到这个第三方的平台去做查询。其他的，你比如说你有的地方的这个平台的API是说要经纬度之类的那也是有一个类似的转换，但无论如何，有一个转换就OK了，转换过来就行了。
	那怎么转换呢？离线的有他自己提供的城市编码表，那你也可以用在线的方式来做。就比如说我们这里大家能看得到，右边的话其实实现了一个函数叫get city code这个get city code是干嘛的？其实就是在线的去获取这个城市编码表，这个其实是它提供的一个接口，我没有记错的话应该是叫这个地理编码。对，就这个参数是干什么事情的，他其实要做的事情就是你输入一个地址，然后他返回你对应的这个编码，这个事儿其实就是一个在线的方式去调用。并且我们刚刚也查了，去获取这个城市编码的这个用量配置，其实也还OK所以可以直接用这2个API的组合去完成从一个城市的名称，一个城市的字符串，让我们变成一个城市编码。
	或者说在它的这个API平台到他这个第三方平台里面，他把它叫做其实要用的是这个AD code，还不只是这个CT code是不行的。这个AD code应该叫区域编码。可以看到在这个返回结果里有这个城市编码，也有这个区域编码，区域编码是六位的，城市编码应该是三位的。我不确定是不是他有这个固定位数的要求，他只写了例如文档不是特别的专业，但是它是中文的，应该大部分同学能能用这个文档去完成自己这个再扩展功能。OK我们把这个逻辑讲明白之后，其实就看这个代码就很简单了。
	这个代码里面我们刚刚有看到在get current weather和n day的这个weather forecast，实现了两个内部的方法，对吧？那我们先看这个keep correct weather干嘛的，他其实首先他去把CT这个CT是我们用户传进来的，变成了一个CT code。然后这个CT code就是我们这儿看到的，他去查询了我们的这个城市编码，调用了这个request的python的库。这个库其实就跟大家之前去在这个function calling里面，我们去访问chat API的时候也用过，这就不赘述了。他其实就是把这个文档里面获取地编码的这个API访问了一下。
	访问的时候传了一些参数，传的什么参数呢？第一个就是这个平台有一个APIK对吧？Weather的APIK放在这里，从环境变量里面获取到的。第二个就是要输入city和address，他要查哪个城市，要结构化什么样的地址。这里我们简化了，我们把这两个都传进去，都用这个CT传进去就好了。他会给你一个，就比如说我只给了这个北京，我没有给到具体的这个结构化的地址。但是他也可以去给你一个对应的区域编码，他可能是默认的一个，比如说上海，他可能就给了某一个区的这个区域编码，或者有一个上海市级别的区域编码。通过这个我们能最终获取到1CT code，并且我们做了一个简单的标准输出，去看当前我们输入的是哪个城市，输出了一个什么样的码，这个码严格意义上来说，我们取的是它的区域编码，那为了简化概念，我们把它还是打印出这个，就取名叫做CT扣。
	然后第二个，就是说我们获取到了这个C之后调的第2个API，就是他查天气的这个API，同样需要传这个key APIK给这个CT code这个就是他的国内的一些第三方平台做的不够专业的地方，就它的命名规范做的稍微差一点。在他的获取天气的APH，他把这个要传的AD code命名为了这个city。我们可以回到天气查询的这个页面里面来。在天气查询的这个API里面，这个city其实是一个AD code，这一段是非常迷惑的。这里我们大家可以细看一下，对它既不是CT也不是CT code，它其实要传的是一个AD code。所以大家如果谁认识的，可以提一个给高德提提建议的这这三个这三列都表达的意义不同，但实际用的是这个AD code，这个也是我实际测下才发现的这个坑。然后我们获取了这个A已经转换出来的这个AD code，为了跟它这个概念对齐，我们假设就给它取名叫CT code号。我们不把这些它的混淆概念在我们这个代码里搞得这么乱。
	我们把这个城市的编码传进去之后，获取到了一个结果。那这个结果应该怎么样去进行处理呢？其实这里是他定义好的一些内容，对吧？但是大家都不看这个上面写的，因为刚刚已经发现有错了，那怎么办呢？我们可以他这里提供了一个可以mock运行的一个代码，这个代码这个代码其实就是它的返回结果，但是也不太稳妥对吧？
	就是从这个API调用和第三方平台的这个开发经验上来说，即使看了他的这个文档和这个，可能都还不一定是最终稳妥的那这里有两种方式，第一种就是你可以拍一个你的notebook，然后把这些代码组装进去，然后去实际调用一下看看，还有一些像比较方便的工具，比如说postman，我们也能可以使用postman来做这个实际的查询。就比如说我们在这儿把我这边收起来。对，我们在这儿不好意思，这个key给大家看到了，这个key无伤大雅，待会儿我会把它干掉的，不然免得大家给我用超了30万，应该大家还用超，我这就先展示出来了，这里的几个参数，第一个是获取程序编码的这个参数。我们可以看到这个key city address，我们都传上来，去send一下是能拿到这个结果的。然后这个结果是可以直接，大家简单一点，就是这种API返回的结果是可以直接丢给我们的GPT，然后把诉求告诉他，然后让他来帮你生成怎么样从里面获取这个response的代码的那类似的也是一样的，这个是我们去做未来几天的请求，有一个额外的参数叫做extensions，在上面有提到。这个API文档已经给到大家了，所以就不再花太多时间了，可以看到这个extension是一个特定参数optional可选的。如果我们选择把这个参数传一个all的话，它会给你未来几天的天气。
	如果你默认不填的话，它其实相当于space给你的是当天的实况天气那对应的我们这个内部函数的实现，这里有一个extension or然后可以从里面拿到一些结果。并且我们把返回的结果，也让ChatGPT帮我们进行了一个F1个组装。好，整个代码的逻辑其实非常简单，就是几步。第一步是把开始我们上节课讲的那三个概念给整明白，定义好open AP。然后在这儿具体实现了从一个第三方的平台，这个第三方的平台的结果，我们会把它返回给我们在这儿定义好的这个response，对吧？这个response再返回给我们的这个ChatGPT，那整个过程其实就是一个传递的过程，对吧？先我们先向ChatGPT问天气，ChatGPT抽象出一些这些服务端要的参数，然后这些参数再传递给服务端。服务端再去找第三方的平台要这些数据，然后把这个数据返回给ChatGPT。ChatGPT根据我们open API的这个schema的一些要求，再返回给我们的用户，就是这么样的一个流程。
	好，然后在这里面还加了一个test方法，是用来检测我们第三方平台是不是调用成功的。我们第三方的平台有没有把这个请求组装好，有没有一些参数没有看清楚，API文档或者跟他的API文档不相符的一些情况。我们在这儿做一些简单的测试，所以我们把这句注释先恢复一下。好，我们现在来实际看看会有一个什么样的输出。因为我们刚刚把这句注释注打开了，所以它会先执行这个test，然后再执行这个面面，是真正把它变成一个pop服务器的一个方法。
	大家能在这儿看到有一个上海31000，对吧？然后上海310008这样一大堆，这其实就对应着我们这儿的这段代码。首先我们预设了两个可能从ChatGPT传过来的必要的参数，第一个就是city可以写中文也可以写英文都不错。对，然后这个是number days，就是我们两天后对吧？上海3100是它的区域编码，那这个区域编码怎么来的？在这儿我们有这个上面给大家看啊。
	Print然后输出了上海的这个城市编码。然后它的天气是我们按照这样的一个方式在输出省份城市，然后天气以及温度、湿度、风向、风力，这是它的返回里有的。然后如果我们要输出未来两天的话，它就会有一个结论是8月4号，这个也是我们按照这样的方式去拼接的date。然后白天然后夜晚白天夜晚这个是留了一个小悬念，就是大家会发现这个是ChatGPT按照它的response帮我组装的一个f screen，然后里面有白天用晚上一会儿我们看一看ChatGPT的response跟这儿会有什么样的不同。
	这就是大语言模型在中间的价值和它的一些工作了，它不仅只是一个二传手，把你的数据，把你API的调用直接丢给用户。而是说我们刚刚的open API干的一些工作也是有价值的，具体有些什么样的价值，我们在这看一看。这个添加插件的这个操作，我这就不再赘述了，跟刚刚是一样的，我们就直接用这个插件，我们问一问，比如说就直接问个北京，比如说北京。
	收起来了。大家看可以看到跟刚刚一样，它开始去调用我们的weather forecast这么一个插件。然后我们右边也确实收到了请求，然后这个北京110000是他的区域编码，这儿有一个任务耗时，大家我把这个还高亮一下，大家能看到吗？这个3.981秒是整个端到端的一个任务耗时。他有写今天北京的天气是晴朗的，温度为29度，风从东北吹来，风力约为三级。大家还记得这是我组织的形式吗？这里写的是这是一个标准的f stream，但其实它在当中给了一些润色对吧？
	那我们问后天，这个其实是基于一个上下文的对吧？就我们再看一下整个客户端和服务端和直接去写一个天气查询的服务端区别在哪？第一区别在于你借用了大语言模型的能力，使得有上下文的使用了。
	就我们直接问的后天，他其实会记得之前有一个message，大家之前如果认真听过课的都知道，这个过程ChatGPT是把message留下来的。他是知道你前文的，前文问了北京，问了今天。那么后天就是基于8月2号的。再过两天8月4号，8月4号白天晚上都有小雨，白天温度晚上温度，风从西北吹来，巴拉巴拉风力约为三级。其实会跟我们的这里的输出这种生硬的表达不一样。但是你要知道，我们的的应用开发当中的API，通常都是很生硬的，它就是一个key一个value。
	但是ChatGPT在这个过程当中，第一他能理解用户要问什么。第二他能把他的这个要问的关键的参数，根据你的API的能力的要求给你抽出来。那抽出来之后，他会发给你。就比如说这里大家能看到city北京对吧？Response是今天北京的天晴巴拉巴拉。
	然后这里是我们返回的是这样的一个格式，但它帮你去做了一个润色，让它显得更加的友好，更加的可读。同时给了更多的咱们的这个叫什么？这个叫数据处理的能力。这个数据处理的能力既体现在输入，也体现在输出，这个是咱们去用这个插件一个最大的不同。包括我们可以继续去问这个，比如说换一个地方，比如说。
	上海。
	静安区，然后咱们的这个比如说静安区，静安寺。
	他会怎么反应？
	上海静安区给了这样的一个输入，得到了上海静安区天气多云，温度29，这个是一个标准输出。我们比如说在问这个。
	好，然后整个这个过程大家其实应该能get到从客户端到服务端完成了这些对应的请求。然后他这边也有这个对应的统计，耗时差不多都在4秒钟左右。然后这样的一个模式其实使得我们可以用插件去做很多的工作了。而且这些工作是有一定的扩展性的。就比如说现在我们只写了两个接口，一个是获取天气，一个是获取天气预报，对吧？那么我们是不是还可以去查询历史的天气数据，比如说我们去查过去十年上海的最高气温是多少，最低气温是多少，这样的事情能不能做？当然是可以的。而且我们要做他的话，也只需要在两个文件里面去做手脚。
	一个就是在open API里面，我们去新增加一个对应的方法的描述。比如说去get这个historical weather of the city，然后在main里面我们增加一个get historical weather巴拉巴拉这样的一个方法。这个方法里面再去调用我们的第三方平台的历史数据，然后甚至你的历史数据取出来之后，可能是一系列的数据。因为你要获取的是历史某一段时间里面的最高气温。那这堆数据本身你有两种方式可以处理。一种方式就是你写一个代码，因为你拿到的是一堆数据，这一堆数据可能你放到一个列表里或放在哪儿，然后你做个排序或者取一个最大值，然后你能把这个事儿给办了。同时你也可以用另一种方式，就是你处理这个数据能不能去调用一个chat的API，让大模型帮你处理。当然这个成本就高一点，你可能会花掉你几分钱，或者这个更便宜。
	然后通过这样的一个方式，你可以去让大模型帮你处理。给了他一堆数据，并且明确告诉他你在处理的这个数据是什么，然后你要干什么。通过这样的方式，其实大模型就可以帮你做很多事情。那就回到了一个刚刚刚有同学问的问题，我们到function calling和这个ChatGPT的bug in它们俩的区别到底在哪儿？
	首先用一个比较直观的图的形式想跟大家表达的点就首先这个function calling是一个左边这个图想要表达的生态。它想要核心做的事情是我们自己的应用场景，我们自己的原来的应用是主要的，它是占了绝大部分的比例的。而ChatGPT在当中只是它的一个小的组件，或者说GPT的模型在当中只是一个小的组件。
	比如说我们现在有各种各样的应用，我们有美团，我们有滴滴，我们有微信。这么多已经有的APP都有上亿的用户了，那这些用户是不是为了做一个大语言模停的打车就得去另一个平台呢？那显然是不必要的。它在现有的这个平台里面新接入一个语言的模型，或者说一个语音的助手都行。它可以是打字的，也可以是说话的都行。这样的一个助手其实就是中间的这个GPT模型，也是我们前面几节课给大家讲的chat API，甚至是chat API的这个function calling。
	这个function calling就可以跟你现有的这些API去做对接，给你现有的这个应用软件有的能力去做对接。他也可以跟你的能力是解耦的，独立开的。它就是一个经过训练的或者说通用的跟用户去做沟通的一个入口，一个语言的交互的方式。
	这个是以function calling，包括像N为主的应用的一种形态，就是大模型。只是我的一个小组件，然后他给了一个跟用户聊天的一个模块，用户可以跟他一直聊，甚至用户跟他聊的过程当中，他还知道我有什么能力。通过function calling这样的方式，能够去在用户聊天的过程当中，帮用户用我这个原来应用的能力。那这个是一种比较典型的场景。
	那第二种，就是ChatGPT，OpenAI做的事情就是他做了一个plug in the score。这个plug in score跟function coding最大的区别在哪呢？它抢占了这个入口，对吧？我们之前聊到了有那么多APP了，但是GBC想说我就是要造一个新的入口，就像我们所有的人都在讨论TIGB出现之后，搜索引擎还有没有存在的价值。目前来看还没有完全替代，对吧？他们各有各自的优势一样。就像GB它是一个大语言模型的应用，它强化了聊天的功能，它让你愿意跟他深入去聊天，它还能帮你做各种各样的工作。这个时候OpenAI的目的就变成了，我现在是一个很好的聊天助手，我有一些基础能力，但是我没有那么多API。那我能不能站在前面，你们这些插件站在后面，然后所有的入口都在我这儿。
	我刚刚其实这节课一直在强调ChatGPT是一个客户端。这客户端就是跟用户直接打交道的这个客户端。他抢占了所有的用户的入口，他变成了一个像google，像twitter一样的应用的存在。然后他把流量汇聚在一起了，他像抖音，他像小红书一样，他做了平台。然后咱们做做这个插件的开发的同学，就变成了给他提供能力，相当于是给ChatGPT在反向赋能，因为ChatGPT本身它不具有这么多能力。那你再反向赋能，把你的API的能力，把你原来应用的能力注入到ChatGPT里面去，然后给它增加了更大的可以覆盖的用户。
	其实这两个的区别孰优孰劣不知道。因为平台经济也是一种经济，在平台上也能长出大V来，这个是非常明显的，并且在各种时代都已经验证过的。但是如果这个平台把握了流量，那它其实就可以决定要不要用。他也有这个生杀的权利，对吧？
	那这个时候其是对于我们开发者来说，更重要的事情还是确定你现在做的这个项目也好，你要做的研发的这个应用也好，它的目标是什么？他的技术上的目标是什么？他如果要取得一些用户上的成功，这个商业上的成功，他需要怎么样快速启动？这个快速启动就决定了你是进入它的插件生态，还是你进入原有的某一个平台。然后只是说你相对于这个平台上原来的同类型的竞争者，你有独特的优势。比如说你有大语言模型的能力，并且你的大语言模型用的比别人好，这也是差异化的优势。所以从这个视角来说，function coin和ChatGPT plug in都是着重在了怎么样让开发者，让应用跟大语言模型去交互，把应用的能力告知大模型，让大模型能够通过这些应用去像加了一个杠杆一样，让这个大模型更有能力了，有更多可以无穷想象的能力了。
	而核心在于这个入口到底是谁那的一个问题。ChatGPT的plug in，那么入口就在OpenAI这里。但如果你是通过chat API，通过function calling这样的方式去借助大模型的能力，那你就会把握这个入口的权益的区别就在于这里。
	对好，然后接着我们再讲一下这个课程项目。这个课程项目我们有一个实战的作业，就是这个基础篇的结题作业。这个作业是明确要大家最好能够参与的，因为它是有奖励的，并且这个作业的要求也是明确的。我看大家有的同学在问，照理这个时代都是什么？就是要实现我们OpenAI translator 2.0当中的一些特性。如果你实现的越多越好，那肯定你会在获奖的这个排序里面更高。同时除了这里列出来的四个特性以外，也推也是推荐大家群策群力的去想一些其他的feature。能够加上去，这些就是bonus，就是一些额外的加分，相当于拿到了附加题的分数。
	我们也会在最终的这个奖品设置环节里面去考虑到大家。这里一等奖是实物500元的奖金，然后二等奖有30名是这个伴手礼，然后还有200名的应该是三等奖。这可能是教研组有一位同学改错了。对，那么就是这样的一个实战作业，期待大家能够实际动手去做一做这个项目。然后open a translator本身变成插件，现在看来可能是一个比较贵的一个操作方式。大家如果在这个过程当中，有的同学把这个V2.0的作业还加了插件化，那我们也是考虑加分。真的对。好，那么今天的这个课程的主要内容就是这些，看看大家有什么样的问题，我们可以在现场回答一下。
	第一我看看到第一个问题就是OpenAI能调用咱们国内的接口吗？可以，我们这个天气预报不就调用的国内的接口，这就是故意选了一个国内的平台。对，这不就调到我们国内的这个接口。因为其实不是他调，是我们这个服务器，就是这里这台服务器在调用。而这台服务器其实本来也是在国外的，就是我现在右边这一台，所以国外到国内一直是没有太大的障碍的，就因为就不再展开了。对。还有同学问现在GPT以现在GPT接口为主。对，这个是这样总结的对，OK有一个同学很好提醒我了，问这个上线的流程。
	对，上线的流程是这样的，大家可以看到我们刚才其实已经讲了这个前三个步骤了。第一个步骤就是我们主要的内容需要写哪三个文件，然后分别去定义插件的这个我把它放大一点，分别去定义这个插件的原数据，定义我们的open API以及我们具体实现的这些API的end points。就干这三个事儿。
	第二步就是你需要去注册你的这个plug in，在c GPT的这个UI里面。然后这里就是我们刚刚看到的，已经展示过了，你需要去develop your own pug in开发你自己的plug in。如果你是要做这个authentication的话，那么你需要去传这个plan ID和这个planet secret。就是有的同学问这个local host怎么就能访问了？他没有做off。那如果做了off的话，就需要去填这样的一些内容，它就能访问了。
	然后第三就是怎么样去激活你的这个八个音，然后当然你需要在那个界面上去选，其实这个就是我们刚刚操作的这些步骤。然后第四就是我们去去启动这个conversation，巴拉巴拉这就是我们刚才聊天的这些内容。这个就是我们开始看到的很复杂的四个步骤，其实刚刚在整个课程的实战演示当中都已经覆盖到了。除了需要健全这事以外，他也有对应的这个要求，我们这就不再赘述了。
	好，然后怎么样去提交审核？这边有啊怎么样去提交审核，就是现在整个提交审核的机制。坦白来说OKI没有明确的公布出来，就是没有一个说法是你这么干就一定能过，或者你那么干一定过不了的方式。肯你比如说你连legal的info都不给，那肯定过不了。你连这个联系你的email都不给，那肯定就过不了，对吧？你这都找不到你这个人，万一你给了一些不合法的。目前看到的就是你只要是一个不太重复的细分应用，比如说就明确现在有一些很火的这个插件了，你非要干一个跟别人一样的事儿，甚至你描述的跟别人一样，那这个肯定是会被不一定会被直接拒绝，但可能不太会快速通过。
	对，然后怎么样去提交呢？其实这个下面都有啊，我这边就不再赘述了。大家可以看这儿，submit一个就好了，这里面会有的。好。我们没有插件开发权限的可以干点啥？可以复习之前的这个function calling，把实战作业好好做一做，同时预习。
	南茜，对，然后关于这个封号什么的，我这边就暂时不回答，大家可以问一问这个班主任什么的。刚才的那个e mail有编写的注释说明吗？这个同学是想问什么？我没有太理解。
	还有一个同学问，天气应用当中的上海静安区也能转换为地区编码吗？可以的，这个我刚刚有花一点时间去解释。就是我们传进去的这个获取编码的这个UIL这API其实是在获取区域编码。然后它输入的这个参数其实是要输这个address。这个address是一直可以到门牌号。对，大家可以看到这儿，所以肯定可以的。他会去逐级拆解的，然后通过这个address去拿到地图的这个信息。然后地图的信息反过来就知道是属于哪个区域了，就能拿到AD code就能拿到的区域编码。
	嘿对的，有同学说的很对，function call算token，plug in不算token。捋一捋这个，是的，就是pluggin这事儿是不算token的。因为你可以理解成我们在这个地方使用的这个plug in跟你调chat API是两回事。
	相当于你是一个服务方，这就跟你你开了一家公司叫滴滴，然后你再给大家提供打车服务，这个滴滴怎么样？这个滴滴部署了多少台服务器，滴滴怎么样跟这个司机结算工资，都跟咱们这个用户无关。首先这个是第一个点，所以OpenAI是这个用户，从这个视角来看，OpenAI ChatGPT就是那个打车的人，所以他是不会找你要钱的，这个你放心。但是你去租用了一个服务器，你去调用了高德的API或者你去调用了第三方的API，你作为服务方，你是需要跟他们结算的。
	申请这个插件开发的wait list一般多久会下来？这个因人而异，这个都是他们来审的，很难有个标准答案。算在使用者身上了没有？大家去好好读一读协议，就是我们用这个插件是不花钱的，我们已经付了20美金的月费了，我们已经付过钱了。
	同志们对你你这不还有限制吗？Gbt 4的限制没了吗？我记得之前还有50次的限制，为什么？应该是因为我用了一个不受限制插件，我试一下。好像真没了，大家可以确认一下，之前这应该是有访问上限的对，现在可能都没了。OK酷那就更不需要花钱了，大家可以敞开用了对。
	如果只问今天的天气，不写城市插件会访问城市吗？好问题，我们看看。我猜他可能会知道我已经在上海了。
	你看这个function calling之前也就要求过了。这个同学可以看一下屏幕，这个直播的我们明确要了城市的。所以这个就跟我们在function calling里面给大家详细展示过的逻辑是一样的。
	大语言模型还有一个能力，就是他能知道你有什么能力，你要什么参数，然后他也知道用户要什么。所以既然用户在问天气，那他就知道能通过我们提供的API来查。然后他又反向去查了一下，发现参数是缺失的，他就会找用户要。并且这个过程当中他是不需要调用你的，因为你的open API已经写清楚了。
	蓝券要预习哪些内容？我们的课程大纲里面蓝券的那些关键概念，建议大家先看一看。
	有同学问3.5和4.0的GPT擅长语言理解这方面的能力不太匹配，你的业务能不能给我推荐一个擅长图形理解的基础大模型？这个同学需要把图形理解这件事儿给大家说明白。对，太抽象了。图形理解然后这个方向图形理解的方向很难。现在所有的学术界的人都在攻克这个事情。
	如果问不相干的问题会怎么样？是正常闲聊吗？对的，就是大家一定要理解plug in的一个逻辑。如果我判断了我现在不用这些plug in提供的能力，它就是一个普通的GPT4，这个跟function tony是一样的。为什么我们最后做了一个function tony和发个in的对比，就是大语言模型在ChatGPT这个聊天窗口里面它是最重要的。所以你的插件它想用你就用，你不想用你就不用。
	你为什么我刚刚说平台流量的逻辑呢？就你写的再好，你这个插件太火了，然后我们也不说因为各种原因，反正他是有权决定到底调不调你的。到时候你的open API写的再好，我也可以不调用，对吧？比如说明天这个贸易战加剧了，对吧？就是不准用，怎么样都不准用，现在还只是封号，对吧？其实封号就已经是不准用了，大家去理解的对。
	插件里可以设置prom或者对输出结果进行后处理。这个刚刚都讲过，输出结果的后处理你可以在API end points这个层面去处理，也可以在open API里面去写清楚你的schema的要求，让大语言模型帮你处理。如果有两个天气类的插件上线，会用到哪个插件？你是指两个都enable了的话，那就看你们各自的open API写的好不好了。
	用大模型去判断的，这个也是问的类似的，语义相近的接口定义会错误命中接口调用吗？肯定会。对，这就跟你去餐馆点菜一样，来了一个你本来想点麻婆豆腐，结果那个菜菜补上写的王麻婆豆腐和牛麻婆豆腐，你点哪个对吧？你不就不知道点哪个了吗？因为就没这东西，你可能以为它俩是一样的。对，不同的用户有不同的to do list，怎么识别呢？这个讲了很久，今天还专门讲的传username，username传过来的。同学username传过来了，存到不同的字典里的。
	现在课程大纲以OpenAI quick star的read me为准。你可以理解课课程项目里面的那个大纲是实际上的那个课程内容。然后我们在一个多月前发出去的那个课程大纲有一些调整，一个是因为在上课的过程当中出现了很多新的东西，我们把它加进来了。比如说function calling就是全新的，之前的课程大纲里就没有。因为发那个课程大纲的时候，OpenAI还没发布方权calling。
	第二个就是我们在上课过程当中发现大部分同学的用户画像的特点之后，我们做了一些顺序上的调整。包括像这个GPU，很多同学在问这个硬件之类的东西，我们把它放到生态篇了。因为会跟私有化部署更加的贴合，放在一起讲。所以实际上的课程内容就以我们发给大家的课件和那个课程项目里面的read MI为准。
	调open API的接口能用插件吗？这个我没太听懂。对，就是什么叫能用插件呢？没get到。然后我理解你意思了，你是想说你能不能作为客户端，既调open API的chat API还调插件的API？不行，我们一直在强调插件是一个服务的，只有ChatGPT能调用，谁都调不了的。但是你要是想用另一种方式去调，就是直接调这个API本身就跟你调高德地图的API1样，那肯定可以，但它又不再是ChatGPT的对吧？
	能介绍一些企业级应用的流程构架架构图案例不？这个不在我们课程大纲项目里。如果咱们有特殊的这种定制化的企业级的需求，可以联系班主任，回头我们再看看怎么满足这一类特定的需求。
	两个插件可以互相调用吗？好问题。其实插件没有被调用过。这个同学这个插件就是一个服务端。对他看不见对方的，但你可以巧妙的设计让ChatGPT来调吗？
	什么叫只有username？那我多个平台username相同，什么？没没太听懂这个人的问题。他可能同学这个同学可能把username理解成一个字符串了，不是这个user ID对。
	能用插件调用OpenAI的接口吗？让gp t和自己对话。当然可以，但是不是你现在用的这个聊天框了？对。
	有没有图形类的模型推荐？老师这个问题描述不是很专业，这个同学对什么叫图形类的模型？
	课程最后的生态篇，能否介绍一下国内大模型的进展？这国内大模型的进展我们会去有这部分的涉猎的对。
	插件你能否做prompt工程，比如添加一些自定义角色和context。你的插件没有大模型，就是咱们在反复强调这个主从关系和这个前台后台的关系。对，你的插件就只是一个API能力，这个API能力里面去定义prop的这些工程没有意义。
	对，大家一定要理解，这是一个三角关系。对用户是就是这个三角关系。用户在前面，ChatGPT在中间，把你和其他的插件跟用户之间难住了。你是看不到用户的，用户也看不到你，但是ChatGPT要来调用你，所以你要说清楚你有什么能力，因为有这么多人对吧，这么已经一千多个插件了，甚至更多。有这么多插件，你得说你得让你自己脱颖而出，对吧？然后你自己做prom的工程没有意义，因为ChatGPT不会理你的。对，只有你做这个应用本身，然后你在去调chat API的时候，你去做创新的工程是可以的。因为那个时候你变成那个用户。
	Plug in的交互过程能出个简单的流程图吗？这个已经描述的够简单了。Plug in的交互过程就只有一次调用。对，就是一个web的典型的客户端调服务端API的过程。
	10.05了，我们最后挑三个问题。
	是的，这个同学说的很好，流程图ChatGPT也可以画流程图。是的，我记得有很多插件已经支持这样的功能，大家还是要多动手，别想着学难的东西还能够躺着学会了。那个in store里面应该有不少这种玩意儿，我觉得。
	这些都。
	应该都是能画图的。我没记错的话，像什么这个插件就能画图。Creative mind mind for data AI是不是大家去搜一搜就有不少的插件都能干活了。对。然后也可以用它官方的这个code interpreter，就代码解释器也能调一些python的库或者其他代码库去画图。
	倒数第二个问题。OpenAI有提供对话方式来搜索用户需要的plug in吗？毕竟一千加这么多好问题，目前我没看到。这就是我说现在plug in市场很卷的原因，它只有一个popular，popular里面怎么选出来的也很迷。对，然后这里列了差不多10。我看三八二十四，不，9三四十二16个。不对，12 14个只列了14个。然后这14个插件是标注了这个postman，然后有一些新上架的会给一些推流，新上架的都已经超过这个，这是八个，是这样，新上架的都已经有这么多了。
	对，所以没有特别好的方式，而且他也很佛系的，他拿这个字母序排的。对你要想脱颖而出，把名字取得好一点，对吧？就跟你这个朋友，这个微信上的一些中介一样。
	这个同学说的是对的，能否正确调用到API接口还是取决于2秒钟的描述。是的，open API一定得描述的很清楚，很确定性的。老师用3.5好还是4.0好？我现在用的3.5的这个问题，在之前的课程里有讲过，各有优劣。然后3.5的这个价格很合适，四点也有它的一些独特的优势，看你自己的需求。有哪些比较好的plug in分享吗？挺好的问题，我现在在用的plug in，plug in就这一个，其实就这个联网的，这个也是一个认识的朋友开发的，还挺好用的，能帮你联网。但是其实之前官方的那个更好用。大家如果有印象的话，之前官方在这儿，在这个地方有一个beta的feature，是一个bing的搜索。后来不知道是微软还是用户分享有什么矛盾，反正这个就被干掉，那个会更好用对。
	行，那我们今天就到这儿，10.08回头大家有什么问题我们可以在群里面再沟通。然后我待会儿就把今天课程当中的代码，我们上传到这个课程项目里。好，然后期待大家把基础篇的实战作业夯实一点，周日我们就开始进阶篇的能劝了。