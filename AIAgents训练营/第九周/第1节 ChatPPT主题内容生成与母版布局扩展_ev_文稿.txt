	Hello, 能看见吗？这个设置每次都很卡，我都还没加载出来。
	Hello hello. 
	Hello, 能看见吗？画面正常吗？我再刷新一下。刚切了一下目录页，但我这边好像有延迟，我做回来半天了，这个上面显示我这还没回来。
	大家能看见吗？Hello hello可能有延时两分钟，我感觉。
	这么神奇，我现在还没做回来这个画面。差不多延时一分钟，谢谢大家。能能听见声音对吧？能听见声音扣一个一，这样我就知道是正常的。
	暂定一下。好，正常，然后就正式开始把这个垫高一点。好，我们就正式开始今天的分享。今天应该是我们ChatGPT的第三节课，也是我们0.3版本。今天主要要讲的内容其实就是这两个核心，就主题内容的生成和模板布局的扩展，承上启下。
	从目录来看，今天主要是分成两部分。第一部分是radio，大家如果有关注的话，radio也是hugging face开源的一个前端框架，我们从github city now开始用到这个GUI。然后在用的过程当中，应该是在国庆假期刚刚结束，10月9号的时候，radio发布了55.0系列的稳定版本。然后video 5也有很多很不错的更新。今天用这个时间正好跟大家快速的去讲一讲，做它的一个版本更新的速度，以及它的一些最佳实践。
	同时radio 5当中最令人眼前一亮的新功能应该就是ask AI，本质上其实就是用AI来生成代码，只不过我们知道我们使用ChatGPT让他来生成radio代码的时候非常痛苦。因为整个radio的库更新是非常快的，所以你大概率你在在GPT里去生成的radio相关的代码是用不了的。现在官方自己出了一个对话式的这个AI，然后在它的playground界面上，我们今天会讲一讲它是怎么样的一个功能，怎么样用。
	除了这个功能以外，radio 5还带来了一些什么样的新的特性，以及它未来的一个计划。同时我们就以一个实际的例子，就是用这个radio去开发一个实际的小的案例，那它在radio之前是怎么做的？在有了radio 5之后又是怎么做的？我们有一个对比应该会更加的强烈。
	然后为什么会引入到它呢？也是因为我们ChatGPT在0.3版本就引入了前端了，这个前端也是基于radio 5来开发的，我们会构建一个maki moda所谓的多模态的chat board。然后这个多模态的chat board可以作为我们未来可扩展的一个界面，它支持聊天，支持文件上传。在下个版本我们还会支持麦克风输入和音频文件输入。这个版本我们在这个多模态的chatbot上面还增加了一些生成PPT的按钮相关的一些事件绑定的功能。这些以前我们在应该是在give hub city nail的时候讲过。
	Radio的一些基础组件，它有一些component。对基础组件有的是可以开箱即用的，比如说chat interface，有的是在radio的blocks下面，可以像乐高一样去排列组合的更底层的组件，比如说chatbot，这些更底层的组件它的文档就非常的繁琐，变量也是异常的繁杂。以前我们去学习它的时候，其实就像before描述的一样，先看文档再去playground里面去做测试。测试完了之后，再集成到你自己的项目里面。现在我们在0.3里就会用一个实际的例子来告诉大家怎么样去做这个改进。当然它现在是刚发布的这个5.0系列的版本，也还在快速迭代，尤其是这个AI的功能，我相信他还需要去做更进一步的版本的迭代。
	因为本身这个新功能刚出现在一些简单的生成方面还不错。但是我也试到了一些深水区，包括它在UI上面也还有一些改进的空间。但这个新功能很值得关注。大家想象一下10月9号到现在也就是应该两周不到的时间，其实这个新功能已经有非常多的用户在使用了，并且有了这样的一个加持之后，我们开发前端未来应该会更加的简洁。同时整个chat PPT的chat部分有一个前端。通过刚刚我们的描述，我们知道radio能作为这个前端。
	Chatbot本身我们使用年限已经非常熟悉了。在language mental第二个agent项目里面，我们做了很多个不同的chatbot。我们可以把那一部分我们已经学到的年轻人note的知识和这个代码模块，移植到我们的ChatGPT里面来。然后这个是ChatGPT的0.3的前半部分的重要功能。后半部分的重要功能其实是为了模板库而设计的。在0.3里面我们引入了一基于编码的布局组的策略设计，这听起来就比较感觉好像有点难比较难理解，但其实它会有一个演进过程，我会待会儿通过跟ChatGPT的沟通的多轮对话，让大家理解为什么是要用基于编码来做，以及如果我们不基于编码。
	在上一个版本，我们知道每一个layout它有一个自己的name。这个name其实我们可以去用正则表达式去做匹配。但正则表达式在匹配过程当中天然就会引发一系列的问题。这个我们在待会儿再去深入展开讲。最后我们会实践一下0.3版本怎么样在一个ChatGPT的界面里面，从一个idea到一个powerpoint文件的一个端到端生成的这个流程，然后以及它背后是怎么样的运作，最后我们再来交流。
	好，首先我们进入第一个这个小节，grade 5的高效应用开发的快速入门。Radio这个框架我们多次提到，也一直在使用，radio 5.0的这个稳定版本，其实是对10月9号发布的没有记错。当然如果现在再去访问它的首页的话，你会发现这个规定5.0是有一个highlight，在它的整个首页的正中间。然后你去访问它，其实是能看到各种radio 5.0的一些特性。它的这个核心的负责人有一个blog有中英版本。
	那么5.0到底带来了哪些的不同，或者说它带来了哪些改进？第一个不同，我相信但凡用过playground，包括我们在用githa city now，那那在githa city那节课讲这个规律的时候，就给大家实测life demo了很多playground里面的一些实践。当时很多同学都反馈慢，就它的加载很慢。那么5.0的首当其冲的第一个改进项就是加载性能的提升。这里有一个简单的动画，我们同时note的时候，我们看到右边的五五的这个版本其实已经加载完成很久了。但是四其实还在转圈圈，就这个转圈圈的体感是非常明显的。其实这个进度条只有4到5秒的时间，可能五是比较快，但是这个我觉得也是取决于性能和你的网络情况。但无论如何，它在底层的实现上确实是有变快的，这个我们待会儿再细看一下，所以主要更新是这四点，我列出来before after，让大家能够直观的去感受到。
	第一个这个加载太慢就不用说了。因为如果我们不只是做一个demo，而是把radio真正作为一个AI应用的前端的话，其实是有很多内容需要渲染的。那么传统前端里面的很多渲染慢的问题其实也会出现，随着你往这个应用，你家的需要渲染的东西越来越多。服务端渲染在前端技术圈就是一个很多年来，应该算是一种通用的做法了。在V65把这个部分也引入了进来。
	第二个就是它的组件，我们的组件看起来在之前的这个版本里就感觉特别老土，就不像是一个很fancy很很时尚的一种设计形态或者设计模式。那么在规律五里面，它的很多组件是有一些界面的，并且它的这个主题也完全做了一次更新。这个大家可以自行去看一下，我觉得不算是作为功能开发的最要紧的。
	第三个是比较重要的，就如果我们想要去做一些低时延的流式处理的一些应用，这里我们看到video 5里面使用base 64的这个编码和OF surface去进行了加速，这个加速是非常能够直观的去体现在更复杂的模态上的。就比如说我们后面会用麦克风来录入音频，我们有可能去上传一些音频文件或者文档。这些文件其实会比我们的文本text要消耗的流量多得多。这些东西如果没有去做进一步的低时延的处理，整个应用会感觉非常的卡顿。这个是V65带来的一个比较好的改进。
	最后一条就是我们今天会重点花时间给大家讲的，也就是这个AI playground。相比于之前的playground，他做了一个叫做ask AI的按钮，这个按钮就支持我们以对话的方式跟radio去交互，然后去交互式的去生成radio的代码。我们来看一个实际的官方发布的例子，这个应该界面很熟悉了，这就是一个标准的playground的界面，没有任何的改变。但是细致一点的同学会发现，在这个左下角，这里有一个what do you want to change，example add examples。SAI它自己也有标注，这是一个beta版本的功能，搞过开源的同学就知道这个版本命名的门道有多深，这个beta版本的功能是指这个功能不会再下掉了，这个功能未来一定会在这儿，但是它的性能还可以再迭代。这个是贝塔命名的一个按版本号里面的一个含义。
	然后右上角我们还能看到它可以一键发布到hugging face的space上面。因为整个radio和hugging face的space其实都是一家公司做的，就是hugin face。所以我们现在也能看到很多的hugin face上面的应用，越来越多的用review在作为前端的这个界面去展现。
	好，我们来具体的看一下它是怎么样去使用。我们在这儿有个SKI。你可以在这去输入你要干什么，add title and description他那输入之后，这儿有个cancel，这边是正在生成，然后生成的代码会跟刚才有所不同，所以可能有点快，大家没有注意，我们先回回回来一下看右边本来是长这样的，我们右边本来是讲name output，这是一个最naive的demo，最naive的一个example。但是它要求加一个title和一个description，那么左边这份代码就会迭代我们看一下这个加了一个title等于这个greeting APP description，等于entire name to receive a personal greeting，就加这两行代码是刚刚这是对话添加的。
	右边艾达如果关注到的话，这里发生了变化。Convert to blocks。Blocks我们已经讲过了，我们也用过了这个blocks。大家如果连这个概念都不熟的话，得回去翻一翻了。刚刚我们在这个左边界面里面看到他用的是一个默认的一个开箱即用的组件，现在把它转成了blocks，然后这绿色高亮的部分，它就会表示出它变动的代码。在我们这儿看到的左边这个代码的这个动态的框里会有一些绿色的高亮。这是一个动画，它在刚刚生成的时候大概会保留几秒钟的时间，告诉你这是最新一轮的ask AI的生成结果或者说变动结果。我们这儿运行完之后，就看到了这样的一个变化。通过两轮的RSVI，它成功完成了添加这个title description和转换成blocks这样的一个操作。
	大家可能会感觉到它的代码好像没改变多少。但用过radio的同学应该都懂，就是radio的代码量不会特别大。但它比较烦的就是里面有很多各种各样的组件，多达几十个组件。然后每个组件甚至有多达十几二十种不同的参数。然后它的整个硅的运行机制，我们之前已经讲过了，如果没印象的回去翻一翻，是一个前端各种操作和数据通过radio server被转换成了一个python可以处理的数据结构。这个数据结构在后端去进行加工，这个加工就涉及到了一个function，这个function就是我们每次有一个关键操作而响应的这个方向。
	在这儿就是我们的great button clink。我们看到这有一个FN这个参数，这个分参数函数返回的就是hello加上name，加上感叹号，那这个name就来自于我们输入的video file。数据处理前处理后处理的逻辑，包括转换的逻辑是清楚的。但是里面的排列组合就太多了。包括不同的组件可以接收和或者说不同的组件可以输入和输出的，这个组件和数据类型也是各不相同。然后我们从chat interface转到blocks之后，也有一些变化，就chat face和chat box是不一样的。然后我们又看到有各种各样的clink。它背后其实都是一些事件监听的机制。这些事件监听的机制的input output又是什么？其实是一个非常繁复的阅读文档的过程，这个是一个好的功能，就SVI。
	除了这个以外，我们还看到有一个这就是关于多模态的，这个我们可以有一个实际的例子，这是官方的那篇blog文章里面，他的那个blog里面分享的一些最佳实践。我选了两个，一个是音频，一个是图像。音频大家能看到它其实是把OpenAI的west product v3 top turbo这样的一个SR的模型，就语音识别的模型，托管到了hugin face的space上面。就左上角，我们通过它的UIL也能看到。然后同时整个这个界面是用规则去作为前端开发的。大家如果关注它的细节，会看到它其实是一个三个tab组成的。
	这里的这个截屏是我用手机，然后放了一段音乐，它的输入源是麦克风，同时它也支持上传一个音频文件，也支持从youtube里面去获取一些L然后通过这三种不同的音频来源。当然你的麦克风就是这个麦克风最终可能也会变成一个音频文件给到，这个weser large with three。但有可能他是流式的，给他这个音频流取决于他最终部署的那个代码。然后你把这个给了他之后，我们看到他通过处理能拿到这个结果，就transcribe转移的功能。熟悉的rap的同学就知道这个是马思唯的一首歌，当然它的识别效果没有那么好，主要还是因为这个歌的语速本来很快。同时手机放的这个声音在macbook的这个电脑麦克风这接触，或者说这个声音转录的过程本身也有一些损失那么大家也可以去试一试，待会儿我们也可以打开这个网页试一试，挺有意思。
	这个是一个音频的输入，并且有多种不同的来源。以前大家都会疑惑，比如说我们在做language mental的时候，能不能用语音输入？其实是可以，只不过语音输入在language mental上，我们就得再加一个语音识别的模型，把我们的音频流或者音频文件变成这个文本，文本再给到我们的language mental去做处理。那在ChatGPT里面，我们会把这个功能给加上，那未来的这个规划，就radio它未来还准备做什么事情？第一个就是我们看到了这么多不同的最佳实践也好，包括我们自己做的，都会有一个觉得限制性的地方。就是radio它始终还是一个单页应用，我们叫one page APP。即使它有多个tab，但还是无法改变它是一个单页应用的局限，如果不了解单页和多页应用的，可以搜一搜这个概念和看一些典型的例子。
	多元应用一个最常见的，就比如说我们经常用过的各种XX管理系统，它有首页，有dashboard，有用户管理权限管理等等，那肯定是完全不同的，这个跟radio天然的一个function处理输入在结束之后，再把输出转换到前端来渲染的这个流程是不一样的。但这个是作为下一步radio的迭代最重要的一个feature，我们可以保持关注。同时我们还能看到，在最后的两个功能，我觉得是跟绝大部分同学是有关联的。
	就是我们的video本身它可以去加载一些各种各样的数据，但是在大模型这个生态这一侧，其实做的还没有那么好啊。一方面是因为hugin face已经做得非常强了，然后他跟video肯定是两个团队，然后跟face的space这边也可以通过去托管，开始逐步的商业化。而radio是一个纯开源的项目，它是没有盈利，或者说它是一个成本的中心，或者说是纯开源驱动的一个项目，可能是提升影响力的。但即使如此，我们也能了解到越来越多的人，包括我们的三个agent都在用radio作为前端。那这个时候，如果我们的这个项目现在我们能看到前面两个agent我们把radio作为前端，到后面我们会去调大模型，这个大模型的调用我们其实是跟哈根face无关的。
	所以说即使哈根自己已经做的很很好了，但radio的用户和他的用户并不是完全重叠的。一定会有一些人他会用radio做前端，但是后端可能用的欧拉玛，可能用的是GPT的API等等。如果我们先抛开API的这个用户不说，那些用obama的用户是不是有可能转变成parking in face的transformers，或者说和其他他跟face相关库的用户。所以这个肯定是我们能看到它的生态在逐步的去做联动了。而且如果可以做到的话，其实还蛮值得期待的，相当于咱们不用学那么多套不同的技术战。最后一个就是它的应用的一个内存消耗这块，它在不断的去做性能优化。中间的这几个功能其实就是它的通用性以及它的处理的数据种类在不断的丰富，这个是它未来的一个规划。
	除了我们刚刚看到的音频以外，其实它这里也提到了图像和视频。所以有一个也是官方给出的一个最佳实践的例子，其实叫做一个dips pro demo的项目。它是输入一张任意的像素任意像素的图片，应该最大支持1536乘1536。对，然后绝大部分的手机照片应该也就这个分辨率了。除非你故拍特别高清的那他也会占你手机的内存。然后把这样的一张照片传给他之后，他可以去做深度的检测，这个还是很厉害的一种算法。当然这个里面也有不同的算法在卷，但无论如何，这个demo的例子还是挺实用的，而且它是可以在手机端去运行的。
	所以简单来说你可以想一下，看一下未来的radio，它会变成一个在手机上面很方便能够打开的轻应用，是一个H5的页面。这个页面我们注意看这个图片的正中间的下面，这里可以上传文件，也可以直接开你的相机，就是你你的电脑的这个摄像头，或者说你的手机打开的这个页面的话，手机的摄像头等等。所以这个还是很方便的一个模式，大家可以去了解一下。
	好，这个是关于规定5.0的一些主要的更新，包括这个RSAI以及它未来的规划。假设我们现在知道有这样的一个新版本了，那我们怎么样更实际的去感受到它，好像更好用了。这里我们就想了一个场景，就比如说我们看到了o one，更新了open IDO one，有o one mini，有o one preview。但是这两个模型都还不支持上传文件，它只是一个纯文本的influence COT的模型。但如果我们现在想要做一个chatbot，它还支持你上传文件。并且我们知道它只要能上传，然后前端的这个数据能被渲染转换到后端的这个radio server这边来，我就能处理这个文件的读写还是简单的那处理完之后，我再把处理结果回给你。这个其实本质上跟GPT4O的逻辑是一样的。
	那我们如果要用radio来做一个类似于GPT SO这样的可以上传文件，支持不同钛的一个UI会很麻烦吗？我们想象一下，现在我不知道有多少同学做过，像我的话肯定之前是没有深入去研究过这个事情的那我要如果来做它的话，就会分成两种情况，一种就是在规定出现之前的情况。就在这之前，我们在get up city now的时候是怎么做的呢？读文档对吧？这个应该是最好的习惯。就是我们去看一下，他要做的是一个可以支持文件上传和其他模态的chatbot。那么在video的文档里面，有哪些check box的组件是可以用的？
	目前我们选中的这个页面是它的chat interface的界面，也是一个开箱即用的chatbot。高层次的抽象。然后这个大家应该都用过了。然后我们还用过的是左下角这里有一个叫chatbot，这个是更底层的组件，那这个是我们在没有规定之前可能去学习它的一个路径，然后看文档，怎么样去做多模态，最好是有限的demo，比较幸运还真的有啊。
	我们在我感觉好像上个月都还没有，这个多模态的这部分，大家可以去去看一下老版本是不是这样。我们看到在demo s里面有一个叫做chat interface Martin da就是支持多模态的一个chat interface，之前的chat interface应该是不支持的，可能chat board底层是支持的。现在它应该被新版本抽象起来了，就是把把这个chat face作为一个高层次的抽象，把这个也接上来了，就好弱一点。在这个里面，我们看到它有个关键参数叫mark moda。当你把它设置为true的时候，这个聊天的chat board就变了，大家去关注，这chat port变成了多了一个跟OpenAI的这个聊天框一样的，可以上传文件的按钮，那这个按钮我们把这段代码放到playground里面去试一下。
	右边大家很熟悉，就是它预览的一个页面。左边是我们刚刚在那个demo里面看到的代码，然后我们试一下，比如说我们选了它，这是这样的，这有三个example，大家看代码的话，哈喽哈拉、莫哈巴应该是三种不同的语言。然后这三个不同的语言我们可以选一个，因为他example选一个hello，让他回了我一个hello，然后我再继续跟他聊天，这个聊天的过程当中，我就去试了一下这个功能。
	一方面是传了一个文件，叫量子力学简介点PPTX。因为它是支持文件上传而不挑文件类型的，所以你传什么都可以。这儿再写了一个字，叫给你一个PPT，然后发给他之后，这个文件和我给他的聊天内容共同作为了我这一次的message，只不过它在UI上显示是两个，因为一个是文件，一个是文本，给到了这个echo watt，当然它会直接返回我一个给你个PPT。然后文件的逻辑我们并没有处理。
	大家去看这段左边的代码就能知道了。这个界面支持我们传文件，支持我们聊天，然后我只要给他发什么，他就回我什么。然后这个文件虽然传给他了，但我却不知道怎么用。
	我不知道大家看完这个demo是不是这个感受，这是我最疑惑的，就是我想查一下怎么让我的chatbot支持文件上传。你这儿写了一个可以传，然后下一步，我就看到message是给他了。然后message是一个像这个字典一样的，用text的这个key可以取出来我给你发的文本。
	那我的文件呢？文件怎么取，怎么用？这个是一个直观的问题。就我的marketing moda chatbot怎么样去获取和处理上传的文件？如果没有这个playground就没有那个SKI，要忘掉它的话，我们会怎么办呢？会跟之前我们去学习规律的各种功能的时候比较相像，就是去搜一搜。
	那这个parameter是哪里来的呢？是我们刚刚的这个demo，也就是chat interface的新版本。它支持了matter moda，所以我去里面摘取了两个还有mart moda的这个关键词的参数说明。
	第一个就是我们看到这个parameter，这个是chat interface parents，也就是我们在给大家跳到这一页，在这个部分，在这个demo里面，我们看到GR就radio点chat interface新增的一个参数叫Martin model，这个参数也就是我上面框起来的这个参数，大家能看到它是一个布尔型的变量，默认的是false。默认这个chat interface就是文本框，不是所谓的多模态的文本框。那当我把matt moda设置为true的时候，我就写了the chat interface will use radio matt moda texts box component for the input。Which lows for the uploading？多媒体文件，大家注意的话，这甚至也能传音频，它不是说一个文本文件，PPTX本身就是一个非常复杂的文件格式了。好，如果啥也没填，这个参数没有去设置的话，就还是用原来的text box。
	那这个时候我们的问题就一步一步延伸过来的。我们从你设置了这个mark moda等于true之后，那现在你的这个上传文件这儿就变成了原来的普通文本框，变成了一个多模态的文本框。多模态的文本框支持你传这个多媒体文件，然后那这个多模态的文本框又是什么？这是下一个问题。
	所以我们接着看text box，这个也是chat interface可以去传的一个参数。它就有3种取值，一种是text box，一种是matt moda的这个text box。那我们就看下面有没有解释，an instance of the这里text texts box or much more than textor box，to use for the chat interface，uh, if you like, what would like to? 如果想要个性化这个文本框的一些属性的话，你就可以去用它。如果你没有提供的话，默认的就是用他的原来的这个样式。
	聊到这儿，我们就会发现没有更多的信息。就单看这个5.0版本的chat interface，我们只知道它的text box扩展了，扩展什么能支持多模态了。然后这个多模态的文本框组件到底长啥样，我们还是不得而知，所以只能在规则里面去做搜索，搜这个大家应该知道怎么找，就是最上面有一个搜索框，搜出来很多是料。然后这儿我们看到的这个第三个check interface，就是我们刚刚才在前一页阅读过的，你去看这行字的话，will use AGR march moda text box component for the input. 
	那前面这两个看着才是好像跟它相关的，尤其是第一个，像是它的定义，那么就走走到第一个来，这个mari moda text box它是属于model 3D的，这个我们在之前讲radio的时候初步提过一下，所以它是属于一个3D下面的组件。那这个组件是干啥的？Creates tes a text area for user to enter string input or display string output. And also这个also是比较重要的。Allows for the uploading of much media bias. 
	也好像啥也没说，对吧？就是看到这儿就是很痛苦，也至少作为我自己来读文档来说是很痛苦的。因为它的概念非常多，然后这些概念你想要去再深挖，其实没有一个特别便捷的方式。就比如说我们刚刚在这个地方，它都是纯文本的，它连跳转链接都没有，还得你自己去搜。这个其实对于一个conception非常多的项目来说是很痛苦的。
	你看我自己做的read me，虽然概念不多，我还是尽可能如果有参考示例，有特定的代码文件，有说明文档，还是会把超链接加上。这样大家一下就能看到，这到底是个什么东西。但现在这个只是一个概念，这个概念很难被我们快速的去消化和理解。所以就有after对吧？就有radio 5之后会怎么做，我觉得它不能去很好的做到自动跳转，各种肯定有各种各样的原因。但我们不说他之前怎么样，我们看一看之后有没有可能去把这个事儿做得更好，更快速便捷。
	这是刚刚那个页面，我们回到这个playground的页面。现在我们知道了有一个功能叫ask ai然后这个SKI它是一个对话框，那么我们现在想要做的事情是什么呢？我们想要去获取这个文件，但是获取之后要再怎么处理，其实是一个非常难描述的事情。而且这里剧透一下，就是他现在UI做的不好，就在于他这个框其实就这么长。然后如果你写多了之后，它前面的就看不见了。它它就只有目前我框下来的这这一块可显示区域是能展现你写了什么，我们叫prompt。如果你写的太多了，你就看不见前面的，然后也好像也不支持换行，我没找到快捷键，我不知道是不是shift或者是command之类的。
	大家如果有试出来的可以告诉我。但我想到了一个别的办法，或者待会儿讲ChatGPT0.3开发的时候告诉大家。所以这儿我就想了一个招，我们就不是说只是简单的去获取这个上传的文件了，我这边提了另一个需求，比如说我们把这个上传的文件作为output，其实这个意思应该是比较明确的。我自认为描述的就相当于，我们把用户在这个chat work里面上传的这个文件作为一个output。这个output应该也是规定的一个专有的名词了是吧？
	在这个语境里面那会怎么样呢？SKI生成了生成了一个什么呢？我们在这能看到这个框起来的部分是它变化的代码，它define一个function，这个function是用来处理的，叫文件的打印，然后GR interface input是一个文件，output也是一个文件。
	这就理解的有点问题。我不知道它的SKI被动的什么模型，但至少看起来他好像忘记了他已经本来有的这个部分，我不知道描述的清不清楚，他已经有一个多模态的chat port。然后我让他把上传的文件变成一个输出的时候，他好像忘记了它本来有一个多模态的chatbot，而是只是完成了我那一行指令的生成，我不知道这个描述清不清楚。所以如果他没有前面的多模态的，而只是完成一个set the uploaded file as output，右边是完成的很好的。但如果结合着前面这部分的代码的内容让他输出，这个肯定是不合格的。因为把主体都给删掉了，所以后面我也想了一个折中的办法来处理，并且测试了一下到底是它是怎么样的一个工作原理，这我们就先看看，反正它生成了这样的一个代码，对chatbot没了，那怎么办呢？
	再给它一个指令，就是set the uploaded file as output，这是原来那句话。然后第二keep the market moda chatbot，这应该是比较直接的一种使用场景，那么我直接就把结果输出来了，少少一些这个PPT，我们能看到它生成了很多代码。左边是它执行完之后的结果了，生成了这个。其实看右边的结果就是它生成了两个tab，因为最后一行它是用blocks生成了两个type，一个就是刚刚它生成的那个file echo，就是传一个文件，就输出也是那个文件。同时他把我的二指令二里面的要求变成了第二个tab，然后他确实keep了这个meter moda chat fort，这就很诡异，就是相当于我们让他做的这个事情，一和二被它理解成了两个tab，那这个肯定是做的不够好了，就变成了两个tab了。
	那怎么办呢？我觉得一个直观的感受要去怎么改造它，就是用表意最准确的，我试了很多，我最后试了应该有4到5次之后，我放弃了这种方式在SKI这个地方去跟他聊天应该是搞不定的那我放弃了最后一次，我试的这个最直接的指令是merge to test。大家如果看到左下角，左下角我现在没有框红框，左下角这儿有一个merge two taps，它没有变化，它的左边和右边没变，整个这个代码几乎也没变，这个就很崩溃那这儿确实是改不了的，但它的功能就是如果你是一个纯新手，你都没上过我们之前那节课，你想要快速去实现一个demo，这是可用的。并且在就算是在这个基础上也想到了一些办法给大家，让大家可以去，应该会比在这儿问效果更好的一些worker around。
	但结论就是刚刚发布的SKI这个beta版本的特性应该是一个初步可用的东西。但它还需要迭代，尤其是它本身自己的代码库，在这么复杂的一个情况下，有很多的概念它其实是需要它的模型去不断的去训练才能做好了。然后涉及到一些复杂的ui还是需要你自己懂一些它的概念的。就是我们前面那节课讲的那你就可以在他给你的一个90%的结果上，你再去稍作改动，应该就能效率翻倍。这个就跟我们用ChatGPT或者这个cloud去写代码其实一样的。
	你幻想它一步到位把你的工作全干完了，这不可能。如果真做到这一点，你的价值就被剥夺了，你就没有必要存在了。但是如果你理解一些概念和这个知识架构，你再用它去做一些重复劳动撸马的话，那效果应该还是不错的那这个是关于我们的最新版本的V6的一些改动，我现在用这个play给大家稍微演示几个，让大家感受一下。
	在这个页面。
	放大一点，这个就是我们刚刚看到的chat interface，chat interface下面新增加了这个interface matt model，长这样的。然后正常的我们本来就可以在这儿去做交互式的测试比如说这个ABC，它应该会返回一个ABC，因为实现就是你给什么返回什么，那么在这儿点open in playground就能进入到这个界面。
	好，进入这个界面之后，右边这个加载，我感觉这个慢，可能是因为整个规划的服务器的问题，你在本地去启动的时候应该会好很多。
	这里也涉及到一些网络的问题，我印象当中这个playground应该是需要翻墙的。
	果然这会儿时间有点高。
	重新加载一下。
	可是我开了好几个窗口之后，内存消耗也比较大。
	这么久。
	因为之前打开的。
	这也太卡了。直接让他左边跟右边，我猜应该是两个服务，试一下。
	果然左边这边已经在重新迭代了，右边正在加载，这个应该是刚分配到资源吧。我猜然后大家能看到左边的这个代码的迭代。老爷。你是不是还没刷新？那CSS好像没没起到作用吗？你再试一下。
	他这边是实时的在展示的，这边的代码应该是一个监听的机制，给到右边去渲染。好，全部生成完之后，他这边又加载了一次，但那个好像并不酷。这个CSCSS和7S好像也不酷。I can。
	卡住了，我靠。
	在最后试一下，把这个。
	拷。
	过来，去一个。New demo里空白的里面，IT is a hard . 
	world. 
	这样可能是我缓存消耗比较多，果然从我那个new demo里的改的缓存太多了。我猜他的SPI也许有做一些memory，然后随着我刚刚那个new demo，这是一个我自己的新界面，里面用的我今天应该用了好几个小时，也许它消耗了很多内存就卡起来了。我们新建一个hello world，这个应该它是不会持久化的，改完就没了，他还挺快的那我们这会儿再来试一下，我们假设我们remove example。
	看看。
	这个example没有。好，假设我们现在不懂什么是这个locks，那我们说这个。
	我们用这个blocks和这个chat work component去替换这个chat interface。这个其实我们当时留给大家好像是一个作业，不知道大家有没有去还记得吗？看他会怎么生成。嘿崩了，我今天也遇到这个bug了，这个还是我后面一页课件的内容。这个我觉得就是它的代码本身，radio的代码在它的模型训练的时候还做的不够，这个问题其实非常简单，如果你会用会的时候你一眼就能看出啥问题，而且这个报错其实挺明确的。就是这个chatbot在这儿，它是不支持用这个title这个参数来进行构造的，它是一个on unexpected keyword argument title。所以这是不行的，是不能这么玩的。但是这儿我相信用惯了ChatGPT的同学会会有个直觉，你把这个玩意儿就考到这儿来，那你再问他。
	他用了一个叫user like button，这个也是不行的。这个就没有太多办法。这里我试了很多次，他没有太多的一次性帮你搞定的办法。
	到这个位置，其实就是得去查一下常见的这个chat box有哪些功能呢？我们这儿为了简单起见，先把这个给删掉。它应该是chat interface和chatbot本身，还有一些东西没有搞搞得很顺。再报了上传ABC message是获得q then handle you the input。尴尬，就这一块，就大家可能像这个用户比较这个参数多的时候就会出这个问题。不稳定只能说不稳定，我们先只能演示到这儿了。
	这个FBI的功能确实比较还不是很好啊，但是我们是有办法造成这个样子的，但这个样子是用一些trick，我们下节课下半节课再来讲，我们先跳过，先假设这个SBI还行，然后我们看一下它的最佳实践有两个，这是社区做的，一个是去感知这个图像的深度，这个是比较直接的。而且我感觉他这应该都没有上真正的去算，真正去算应该是走这一条，他得要一个GPU1个share GPU来实际去算。这个最佳实践的这个UIL在课件里到时候大家可以去看到，这个是他成功获取到了一块GPU，然后实时算出来的。然后whisper这个可以做一个预告，我们后面也会用这个控件，就是audio的这个控件。大家可以先听一，我不知道能不能听到。
	有可能大家听不到，因为这个是我的mac的输出，可能会跟mac的输入是是是没法通的。这个是从麦克风输入的，也可以从文件上传，也可以从youtube里面获取到一个UIL。然后我们可以现在实时的去试一个，我们试一下clear。测试你的语音识别是否准确，stop转录submit。这如果获取不到资源，也许就得等很久。果然这。
	应该。
	是没资源，我试一下这个，当然这个模型这就可以了。这次拿到了资源就测试你的语音识别是否准确。这一块的功能，其实大家可以想象一下，后面我们要做的其实是类似的。背后我们也会去部署一个whisper的模型来做语音识别。
	然后我们的前端也是去支持这样的一个输入的。他的场景就是领导给你发了一句话，就是把明天的某某某项目的内容，你给我做一版PPT。或者是领导是发的这个语音，这个语音可能是我们可以把它转换成一个文件，就他可以发了60秒语音，发了好多个，那这个60秒语音可以转成这样的一个audio file，这个audio file再作为输入给到我们接下来后面要去讲的0.3的这个chatbot来进行处理，是这样的一个流程。然后这个是关于我们radio的这个5.0的这个新版本的一个竖栏。好，我们接下来会讲一讲这个TIPPT0.3，也会用到这个5.0里面的SKI来帮我们去完成一些简单的代码好，那我们我看现在有这个，现在回答两个问题，让我们再进到0.3版本，然后再回答整个0.3的问题。先看看大家现在到这儿有没有什么问题。
	把这个关了，有点消耗内存。
	name. 
	看大家有什么问题吗？不知道是不是有实验，大家看的有点慢。
	大家有什么问题吗？就关于这个5.0的这个系列。
	那应该没有。对我看这个手机上应该也同步过来。没有，那我们就往后推进，讲一下这个0.3的产品研发和设计。
	对这个部分好，我们就来讲一下0.3的这个产品设计和研发。好，在上一个小节我们把radio 5这个新版本的一些特性，包括功能给大家做了一个速览，包括它的一些SKI的一个现状，但我其实是比较看好这个功能的。这个功能其实在线上的用户，像我今天跟他问了这么多轮，都会成为他的训练数据，而且我相信他应该也很快会找到一些他现在生成的不好的一些case，去不断迭代他的模型，ChatGPT的0.3是一个承上启下的版本。他把我们前面学到的这个年轻的chatbot radio的这个check out，以及我们怎么样用radio的这个button，就是我们的按钮去做事件监听。然后去串联前端的数据和这个内容的生成，服务的结果，以及最后跟这个PPT的生成模块结合起来。同时0.3还完成了一个比较重要的为未来可扩展考虑的一个部分，就是我们的模板库的一个初步建设，制定了一个标准。
	整个ChatGPT0.3的业务的主流程，我觉得可以分成这四部分。大家去看这个四个圆是我们的主要的模块，就我们的ChatGPT内部的模块。然后箭头里面是它流动的数据data flow。那么radio它其实给到我们的chatbot，这个chatbot就是我们能欠的这个chatbot是一堆message，就我们对话框里的这个message聊天，我一句模型一句或者说AI一句我一句AI一句。
	那么check bot生成的是什么呢？是格式化的，按照我们要求的这个格式的内容，我们要求的格式，其实第二节课就第一节课第二节课都讲过，就由这个首先它是一个markdown的格式，然后这个里面又分了有title，有这个bullet point，有这个body point的脚本代码内部的一把叫做content，在layout这一侧，然后只要你是一个formatted conference格式化的内容，那这个格式化的内容就会进到下一个流程。其实我们整个0.2版本的它只包含了后面这两个圆。大家如果有印象的话，这个input power和PPT generator。而input powder的输入其实是一个文件，就是0.2版本的这个输入是一个markdown文件，而0.3版本把这个markdown文件改成了由chat port生成。而这个chat word生成它的需求来源于哪里呢？来自于radio这个前端用户的一个idea或者一个要求，一个输入message。好，那么到后端这里接起来之后，后面两个流程大家应该就熟悉了。
	Input powers把markdown解析之后，变成了我们ChatGPT里定义的一个数据结构，叫powerpoint。然后这个数据结构power point又会去调用python的PPTX这样的一个库，然后这个PPTX在我们的自己内部有一个PPT gene rata的模块，去用这个库完成了powerpoint这个文件的生成。然后这个部分明面上看，我们新增加了两个主流程，但背后还有一点比较复杂的，就是在在流程上看不出来的，但是性能上有提升的就是布局。我们在0.2里面我们的布局其实是一种内容的组合，只有一个布局，只有一个layout。但我们希望在0.3变成多种，并且是可以自己去选的，有一个布局组。大家如果去看0.2的代码里面有一个to do，那这个to do在0.3里面已经完成了。
	好，那我们具象化一点，就举一个具体的case，就这个message是什么？假设这个message就是介绍一下黑洞，我相很多人都听过这个词，但是黑洞到底是什么？其实首先我们又不是物理专业的，可能没那么深入研究过这个概念和这个方向，那么黑洞是什么呢？
	我们假设用GPT4 omni来驱动我们的chatbot，那它生成的结果是这样的，被动的概述。我们先不管它是怎么生成的这个formatted，但它的理想输出应该是长这样的，黑洞的概述，什么是黑洞？黑洞的形成、黑洞的类型、黑洞的探测、黑洞的科学意义，这个格式是符合我们要求的，然后这个格式这个markdown会给到input mother input power。这个是我从log里面捞出来的日志大家能看到它统一有一个log的输出。然后在这个input partner里面会把它变成一个powerpoint的结构，那个powerpoint的结构最终到我们的这个PPT generator里面会有一个这样的结果，就二跟三之后的产出中间结果是设置幻灯片标题，这是PPT generator里面的debug级别的日志。然后最终会生成一个powerpoint的文件，长这样，像这样有黑洞的概述，巴拉巴拉的。
	但到这儿其实大家就发现一个点，就是这个主流程里有一些明显可以优化的。也就是我刚刚说的，在流程的看不见的地方是可以优化的。在最终的这个PPT文件里面，我们已经能看到它其实不只是一种格式了。
	如果有印象的话，如果是0.2版本的代码，它如果是title and content这样的一种内容的话，它只有一种布局可以选，就是我们在config里面去设置的那个布局，并且它还是得在我们的模板里面能匹配得上的话，他才能用那个布局。但现在同样是只有title和content，右边的这个文件已经有很多种布局样式。那这个布局样式是需要我们去动态的去选择的，或者说它是随机选择的都有可能。
	这部分也是0.3的一个核心的工作，那具体怎么做？然后怎么样制定一个标准，让我们的模板库都能按照这个标准去命名，然后让我们的整个动态可以去管理的这个layout t manager能够有效的去运行。这个也是一个0.3主要的一个改变。
	像所以我们把整个这套流程到模块到数据流的变化总结起来，其实0.3的核心工作就是这四条线，我们去看一下的话，第一条件我们的radio GOI需要完成一个chat interface，就一个多模态的对话的图形化的界面，再加上一个powerpoint的一个生成的触发事件，一个按钮也好。因为我们要想象的是，它不是一次生成就变成PPT的。有可能会有很多次的对话，你最终满意了，你才会变成那个或者说才去生成那个PPT文件。所有的做AI生成PPT几乎都是这样的一个work flow，大家如果去看一看的话，所以先是在chatbot里面聊，包括提供各种各样的输入原材料去聊，输入原材料的那个可能是未来的版本，我们会在radio那再去加更多的处理逻辑，等你满意了它的内容之后，你才会去真正的去生成这个PPT。
	这个是前端就完成了整个workflow的一个界面。但是在后端的处理，这其实是几个过程，就比如说这个内容是怎么生成的，需要有一个真正的大模型去驱动的chatbot在后台去运作，并且它要有一个提示词，然后用年前来写这样的一个check port。然后更关键的就是内容生成好了。我们现在点了这个powerpoint generation的这个按钮了，它要去生成一个PPT文件的时候，内容是固定的。但是内容的样式，我们希望他能够尽可能的花枝招展，百花齐放一下，就是我的这个模板布局。
	那怎么样去管理这个模板的布局？然后基于内容来管理的时候，这里就有两个事儿需要去做。第一个就是假设我的title and content这样的一种内容，喜欢各种各样的不同的layout。假设有四个不同的layout都是可以去放置title and content。那怎么样去做这个匹配？就是我我的这个内容和我的这个layout去匹配，以及我从我的PPT模板里面加载了一堆layout，然后这有一堆layout name，这个name又怎么样呢？被我的ChatGPT加载进来，这也是一个难点。
	然后最后我们还会看到有一个end to end的端到端的一个集成。这个集成就是把前面我们明面上看得到的radio chatbot和PPT generator，加上可能我们看不见的动态布局的一个生成匹配串起来。这个串起来是整个0.3最后端到端能看到的一个效果。
	好，我们就一个一个来，首先要解决的其实是内容的生成。内容的生成按照惯例，我们这个就不会像之前讲的那么细了，因为它确实也简单，我们还是用ChatGPT帮我们来写prot。那这个prom长什么样的呢？我看我们需要写一个英文的prot，满足三个要求，RTF的架构。第二个就是角色是一个chatbot，并且擅长回答用户的各类问题。第三个要求其实是关于格式的，就是回复的时候格式应该是适合presentation括号powerpoint的主页的形式。然后给了他一个参考的样式，这个参考的样式就是我们0.2版本给出的输入内容的一个参考样式。大家如果有印象，这应该是比较偏直觉的一个灵针，就是最近比较火的一个说法。
	灵针提问，就这样问TIGPT给了一个回复，长这样，大家可以简单读一下。你是一个知识渊博，能力超群的机器人，并且你擅长回答各种各样类型的用户提问。任务就是当回答用户这个提问的时候，你的回答是需要一个presentation friendly style shooted for powerpoint slides，就是我们中文描述的这个要求。Organize the content into a structured slide by slide layout，然后format是长下面这样的structure，your response as follows长下面这样这个写挺好的，因为我们本来他对他的要求也很简单，那生成了一个什么呢？
	这里是我在ChatGPT的playground，这个就很熟了，我就不再去贴太多的图来展示了。我们跟他交流，把刚刚那段内容放成了system prompt，然后user就提问黑洞是什么？Assistant是GPT four omi就我们最终要用的那个大模型，它的一个生成结果assistant。黑洞的概述，什么是黑洞？黑洞的形成，黑洞的种类，这又出现了一个一级标题，显然这个是不好的一个生成。然后最下面还有一个黑洞的性质，这也是我们不要的。我把黑洞的性质挪到这儿来再结束再截取出来。黑洞的性质，黑洞的影响。
	图片说明图示黑洞示意图图片路径images black call diagram PNG的图片路径是编出来的，所以到这儿我们就发现它生成的第一版的pro肯定还是没法用的，主要其实也是因为我们给他的要求写的还是有点问题。稍微反思一下，我相信大家应该现在有这个水平了，其实就三个事儿需要去改。第一个事儿就是这个mean title这个主标题是由我们一开始写的中文的prompt，由这个模型由ChatGPT帮我们生成了英文的prompt，而继承过来的一个词叫主标题。而主标题其实并不准确，我们在PPTX的这个代码库里都能看到它有presentations title或者之类的说法。所以我们就跟他提到这个改进的要求是，首先告诉他上面这个是使用prompt后的示例。
	然后有这些问题，main title改为这个presentation的主题名称，作为整个slide的首页。不要生成图像和对应的URL，以免它出现幻觉。或者它为了去满足你的format，他只能是硬生生的去造一些图出来。但未来我们的计划是说，图片是不会让语言模型去生成的，我们更多的是会用纹身图的模型，基于这些语言的内容，在合适的去生成一些插图配图，这样再去组织你的整个PPT的内容。在这儿我们先预告一下，先不说这个具体怎么做，所以不要生成图像和对应的UIL。
	第三个就是这个main title的标题的级别只能出现一次，就是我们不能出现四个一级标题或者说presentation的title。那么改完之后它更新了这个内容。You are肉没变，task没变，format改了，presentation thing就是演示主题slide title，然后image没了。大家如果去细看的话，ensure that the main title appears only one of only on the first slide as the presentation scene这儿其实就有一个小的改进，就是这个main title已经没了，所以这儿换成presentation steam就可以了。所以把这里我就跟他提了一嘴，就把这儿改了。最后这里确保presentation thing appears only on the first slide就可以了，这个也是我们0.3最后使用的那个版本。
	而拿着这个版本的system prot我们去试一试，在这个case这个radio demo就是我们前面已经多次出现的那个多模态的chat interface的demo。那么我们让他介绍一下黑洞，它生成了这个结果，这个也是radio 5之后的一些示例。看这个样式大家就很熟，像什么呢？像open web UI大家还记得欧拉玛有一个web UI，后来改名叫了open web UI它渲染输出的这个就是AI生成的结果的时候，它也会渲染markdown，就跟现在这儿做的一样。而之前的我印象中这个chat t他没有做这么好的前端渲染。所以现在已经不会出现presentation的same出现多次，也不会出现图片和图片的URL了。
	这个结果至少当下我觉得是可用的，我们可以再往后推进，但这个模型包括这个prompt还是可以继续迭代的那有了这个之后，假设我们现在内容搞定了，内容的格式也搞定了，并且我们前端也有一个可以用来生成内容的的interface。再下一步要做的事情就是我们刚刚那个主流程在大家脑子里，your radio message，然后chatbot formatted contents。现在到了formatted contents，那再下一步是要一个input puzzle，要把这个内容传给input puzzle。Input poser和PPT generator统一都在服务端，我们需要在gradual这个前端加一个按钮来生成PPT那加了这个按钮就会触发后端的服务端的这些逻辑，然后把这个formatted content传到服务端去。
	所以怎么做呢？这儿其实是我想出来一个walk around。也许他长期来看不一定做的这么差，就radio不一定做的这么差，所以还是大家可以去多试一试。并且这个workaround它有它的这个原因，这是怎么搞的呢？给大家简简单的去介绍一下。我们看到这里这个截图里面，首先我在他的写代码的这个区域加了三个短横线，经常写prom同学就知道这就是一个分割线。而且我们在在language mental的最后一节课教大家提示词的，就深入理解这个prompt的时候也提过，这就是一个分割服务，相当于分开了前面是一段，后面是一段。前面可以是上下文，可以是素材，可以是指令，但下面反正就是另一个要求，另一个事儿。
	我们把上面作为context分开之后，这是我要做的事儿，我们说。Add a generate button with handle function, generate slice, uh, inputs, chat history and out of the file. 为什么呢？就我们看到这段代码，其实它是一个很简洁的版本。这个版就是如果我们熟悉代码的同学就知道这个demo等于这部分的代码，它就完全就是一个其实就是一个这样的形式。我们前页其实就这样的一个形式，只不过我们改了它的title，改了他的example。然后大家如果去看改了他的example，改了他的title，并且这个example都不应该这么改。但是我为了给大家方便展示这个demo，因为这个一个example里面是他第一次要输入的一个示例，而不是一个说明。
	好，然后这里有个files是它可以上传，也可以有一个实例。然后接着我们看到指令写在这儿，因为如果你去试一下，你把这个指令写到它这个SVI这个框，这它其实当你写到outputs a file的时候，你到前面已经看不见前面写了什么，所以很恶心。但是它的推荐用法里面肯定不是这样的。那你通过这样的一个实验，你也就知道了SKI它背后是怎么运作的，它的数据是什么？他到底有没有用这段代码？如果他都没有用这里的这段代码，这个指令肯定是无效的。
	我们开始在上一个小节的时候，其实试过就我们让他，大家如果有印象叫做set the uploaded the file as output。然后他好像就没用这个代码似的，就直接把整个规则界面都给改了。然后我们在这儿去试验一下他到底有没有用这部分的代码，也是一个很有趣的测试，用了吗？然后我们看到这个是它生成的结果，首先它生成失败了，它生成失败了，但它在尝试满足我的要求，这个是我刚刚在这里写了一行内容，这个二的AI这里其实是空的。然后我们在20个AI之后，它生成的结果是左边这个部分，是这个结果。这个结果里面它有一个bug，这个bug是啥？在右边我也框出来了就是。Cannot call clink outside of the radio blocks. 
	Context就是我们不是让它生成一个generator的bottom，我们要让它生成一个PPT，生成PPT的按钮。然后这个生成PPT的按钮，它也这些代码都有了。但是他的整个clink事件监听是不能跳出一个python的VS语构造的上下文的。所以这里的红框应该把它变成一个GR的blocks，然后在里面去做这个相关的一些事情。
	我们在language mental里面都用过这些语法和这个API，大家如果对它很陌生的话，可以去翻看一下，所以需要把它变成一个blocks，那这儿我们就写add a radio blocks context，那么会怎么样呢？生成了，大家去注意一下，这个不是我手动改的，是让他改的。大家再看一下这个变化，其实就是这里的GR chat interface，generate button clink, 要把它们放到一个block里，那就让它放到一个让他加一个block的context。他知道要这么加，他生成了一个chat interface，然后生成了一个generate button，那这个button的名字也是我要求的，然后也做了一个button clink做监听。然后这个button clink的这个handle generate function，它的输入是一个chat interface，输出是一个GR file。UI成功生成了，是我们要的样子。到这儿为止其实是超出预期的，只是我没想到后面去做上一个小节的作业的时候，他他他这么多别扭的事情。
	但是从这个结果来看，它其实是前景还蛮不错的，只是它的训练数据和模型可能还需要再迭代。所以未来我觉得他如果迭代到一个稳定版本，一个RC的版本或者一个GA的版本，那我觉得这个ask AI应该还蛮好的。而且我觉得这是一个很好的事例。未来很多的开源项目其实都应该干这个事儿。其实南倩也在干这个事儿，南茜的这个作者她也做了一个报，然后去问南茜的各种API怎么回事，还没这个好用。所以当然能签的代码量也比较大，所以大家可以去去期待一下。我觉得未来的开源社区的代码的学习会逐步转变成一种这样的方式。
	好，那UI成功生成了，那能用吗？这肯定是第二个问题，能不能用试一试输一行字。报错了，这个是我在刚刚的右边的这个界面里，出了一些字之后报错了。
	报错了是啥呢？其实就是红框里框的这个部分，video invalid component era，简单来说就是我们的按钮，它的事件监听的输入不能是一个chat interface。这个问题其实在language mental里面，如果有的同学去挨折腾的话，应该也会遇到过，我们有折中的办法来处理。这个就惊艳了。
	但为了去试一试它行不行，我尝试了很多轮，尝试很多轮，但最终也不行，并且遇到了这样的一个bug，就是chatbot in IT，我们刚刚也遇到过的，就chatbot的构造函数是不支持title这个参数的。但是我们看这个代码的改动项大家应该能get到。其实我手动把它改，就我们的这个按钮clink的支持GR check bot，不支持GR chat interface，就支持check bot这个组件，但不支持chat interface。这个高层次的抽象，所以最终的这个代码它确实没生成，但是那个样式已经搞定了。而且其实你只需要再稍微查一下，你就知道support不能用这个title，要用别的，最终怎么做的呢？最终是长这样的，包括这里有个CSS，这也是我让video生成的还比之前好看。
	它是一个所谓的动画效果，在手机上打开会比较好看，然后最终生成是长这样的，就为什么title不要再加到这个里面了？其实是因为我们的blocks本身可以有各种各样的title可以去设置，然后你也可以用markdown来设置。这个在language mental里用了很多了。那具体来看我们改了什么代码？第一，我们不能把这个check interface传进去。所以我们就定义一个chatbot，叫做内容生成的chatbot placeholder。这个也是language mental里用过的，我们不再用example了。因为example是点一下就没了，而且它会作为第一次的输入的。而place holder是变成了一个当你还没有开始对话的时候，它默认站的这个站位符，聊天窗口的高度调一调，传的这个类型message。
	然后同时再定义一个GR chat interface。这里要再再强调一下，就chat interface这个组件才会最终在那儿显示出来，而你指定了一个check bod，它是不会展示的。然后这个chat interface有一个generate contents的function来做响应，这个我们到时候看是整个代码的时候再给大家去讲的。
	然后第二个注意的点就是我们的generate button。这里generate button的inputs就改为了content chat box。Contents chatbot就是我们的这个chatbot组件可以传进来。因为interface是包含前端的这一套东西，而且拓的这个组件才是我们只是输入的这个数据转换的部分。
	看一看代码，包括回忆一下language mental部分的代码，应该都能记得和get到这个是前端的部分，我们整明白了，然后相当于现在再整理一下思路。我们有了一个video的前端，它能够聊天上传文件，然后同时他的聊天是有一个能欠的chat port去驱动的。这个年轻人的chatbot会生成满足我们格式的markdown的内容。
	好，接下来我们要把它跟我们的PPT生成的后端逻辑去对接起来。在对接起来之前，有一个需要给大家这个在楼就是chatbot能签的chatbot代码。其实就是我们大家去看这两页，就是我们在language mental的agent base里面的代码的简化版本。因为我们还不需要去加载info，在language mental里面我们的chatbot还是有不同的名字，每个场景都有一个chatbot，在这儿不需要。然后我们的记忆的功能，也是用的年前的这个check history，所以这个部分是完全复用的代码。只不过我们的prompt是我们刚刚看到的用ChatGPT生成的prompt，这个应该就串起来了。那串起来之后，我们再回到后端的部分，就有了内容，怎么去生成PPT文件。ChatGPT当前最大的痛点，大家如果经过这两个版本之后，你很多人都在问，就是内容有了，但内容还可以无限迭代的。
	但是多条腿是个木桶定理，现在这个木桶最短的这个板就是布局。我的布局不多，尤其是0.2版本。我们看到0.2版本里面这个layout mapping是一一对应的，所以你一种lout就绑死了一种内容的组合。那这个怎么解决，布局怎么解决？落到代码上，我们看到它就是基于内容来实现了一个布局策略和管理，具体来看其实就这一两部分的代码，0.2我们有各种各样的layout strategy，这个layout strategy里面有一个layout name。这个layout name会去我们的layout making里面去获取。所以说人话就是我们现在在PPT特指0.2版本，在PPT模板里面设置好的layout name，要跟这个部分的strategy的layout name匹配，对起来非常的hot code，非常的硬编码。但是它先实现了这个流程，也让大家理解了这个流程，理解了这个hard code的一的过程，才可以去灵活的变成1到11到100。
	有了layout name和这个PPT模板里的一一对应之后，我们才可以去找到那个真实的PPT里的布局。那个布局最终才能在PPT generator里面用起来。这些strategy最终是在我们的layout manager里面去使用的。所以我们在看这个layout manager这边，他自己内部就定义了4种不同的布局策略，是跟着我们的名字直接来的，非常好理解。Title only，title and content time and picture，title content picture, 然后SIN out就是我们在slide builder里面去调用的。大家还记得的话slide builder是用来构建单页的slide。然后slight builder里面最终会获取一个layout，然后再把它变成一个slide，这个过程我们可以直接了当的说，它确实是一个hard code的layout map，就是一个in memory的law map。
	你能够变的就是你的这个模板文件里面的布局，并且只能编一张，那一旦你的内容多了之后，看起来就非常的乏味。所以我们希望把它变成一个什么呢？变成一个动态的mapping。怎么样去实现这个动态的mapping呢？这边我直接抛最终的思路，但我们可以去看它是怎么演进的。
	最终的思路就是说首先我们的内容，我们是基于内容的排列组合来去选不同的layout。所以我们可以直接把内容的类型就固定下来。就比如说我们看到有title，有这个content，有picture，未来可能还有chart cable、shape、smart arts等等各种各样的类型。而这些类型在刚刚0.2的实现里面有一个最麻烦的点就在于我们需要去做名字的匹配mapping。而这个匹配最终实现的方式，肯定不能用一这个硬匹配直接对上号，所以你会想到可能会用正则表达式，这也是我们待会儿会给大家分享的这个改进的过程，可能会用正则表达式来做匹配，然后这个正则表达式的过程你会发现非常的痛苦。
	所以我们看到这个思路，第一步我们需要有一个名字的从名字到类型，就从内容的名字到内容的类型。然后第二步left name, 我们也可以把它的格式再简单一点，不要整成无法收敛的一个状态。之前的那个名字其实是取决于我们从office的官网下载下来的一个模板，那个模板里面有一些名字我就继承下来了。
	现在我们把这个规范给它做的更好一点，就是这个模板的layout的名字的规范做的更好一点。之前会出现title only，然后出现我们把有了这个type的概念之后，这个type就是上面的content type，会有比如说title and content title content and picture。这个and其实也是一个会比较麻烦的事情，我们可以把直接挪掉。
	第三个就是我们会发现当我们想要做多种布局的时候，就比如说title content，我们有title content有title content 1，有title content 2。但最开始的这个title content是没有零的那为了简单体现，我们就把这个序号作为一个必要的number设置在这里，你的第一个这种类型的layout就叫比如说就叫title content 0，第二个title content就叫title content 1，然后以此类推，然后把and移除掉，然后这个是用正则表达式就能想到的一种解决办法。但它非常麻烦的一个点，我先把这个整体思路给大家讲了，再看它的迭代，会有一个很很麻烦的点，就是我们可以直观的想象一下title content和content title。如果你要用正则表达式去匹配这两种lout name的时候，他们是以首先他们从这个最终的结果来看，他们应该是一种的样子，就是title content和content title这种lout name理论上是一种lout。除非你要把整个模板库做得更细致一点，你认为它都是有顺序的。再说目前我们在这个版本这几个case，我们认为它是一样的内容的类型决定的，那这个时候你会发现用正则表达式很难匹配这种场景，就是content的title和title content。因为你在最终去基于内容去比对的时候，你这个值是无法确定的。并且正常情况下这俩应该是同一种leader name的，但正常表达是做不好，那怎么办？
	其实核心问题是出在了这个顺序影响了匹配，就是我们的type的顺序影响了匹配。有一种比较常见的思路，其实就是编码的方式，就encoding的方式，就应把我们的原来的这个layout name变成一串字符，不叫字符串变成一串编码。就跟我们看过的one hot，或者说我们在大模型里面的这个token一样。本质上其实是解决这个顺序的无关性，并且我们这个编码未来还可以再去做扩展。
	在当下的这个编码的系统里面，我们可以认为类型决定了layout的策略。然后这个策略下面可以有很多种不同的布局。就比如说同样是title and content，可以有十种20种布局，因为它就是一个标题加一些正文。他也没有什么配图，那你无非就是在这个情况下，怎么把这个文字和标题摆的好看一些。
	那这个时候我们可以把它们就像这个二进制一样的，比如说我们的title就放在了一个零一串的最小的一位，content在第二位，在第三位。比如说未来有chart它可能在第四位，如果是有table它可能在第五位，这个是我们可以去定义的那假设未来我们的这个title content，它还有个数上的差异的时候，我们还可以再次去扩展这个编码的系统。但无论如何，通过这个方式，整个layout name就被我们可以通过一个字符串的处理，把它直接就拆成了离散的一个一个的type。然后每个type有自己的权重，那么我们就只需要把neot name转成一个可以用来做权重计算的最终的值就好了。那就不需要再去做复杂的正则表达式了。而这个值就是最终算出来的这个零一串的这个值，不知道这个描述是不是很复杂，我先把这个整体思路给大家讲明白，应该就好理解了。
	未来其实你的命名都可以用这套编码系统去做扩展。我们来看一下是怎么一步一步演进过来的，这样大家会好理解一点。我们看这个我记得有分享这个UIL，对，就是大家能看到这个布局组策略的设计，最下面有一个share的UIL。这个UIL是这个思路怎么演进的一个过程，也就是我们这儿展开的这个UIL，我们来看看放大一点，简单来说就是我给了一个这是一个新的对话。这个新的对话里面我给了他这个mean点PY，然后有了这个命点PY的输出，就是命点PY的一个输出。然后给了他confide点PY，也给了他layout manager点PY。当然这个都是有划分的，不同的划分都通过这个分开了。然后一开始我写的这个版本就是比如说我们要扩展这个代码，使得layout strategy有多个可用的幻灯片布局，把它放大一点，有多个可用的幻灯片布局的时候，可以从中选择一个。这段话其实是写在我们的to do里面的，大家如果没印象的话，给大家再搂一眼。
	在0.2。的source。
	South里面有一个the art manager。这个to do大概大家应该不知道有多少看懂。那out的这个manager 0.20面我们写到了，我们需要为每一种布局策略准备一组候选的布局组，然后定义一个布局策略标准。扩充模板的时候，模板库的时候要去校验布局的名称和站位服务。理论上这个是做好了，这个还没有去做校验这个校验就看是离线去处理，还是note动态加载的时候去处理了，所以这个凸度其实一直埋在那，我们再看他怎么做的。
	我们希望当这个lid strategy有多个可用的幻灯片布局的时候，可以从中选择一个。就比如说我们现在打印出来有这么多个title and content，那这个是啥呢？我直接给大家展示一下，这是早期的状态。我们在。Complete里面。把这个退出了。
	好，我们在这儿可以看到，但现在已经改成最终的样式了，有title content。这个title content我们把它放大一点就是。就是有很多页，这个是只有title和内容title和内容title和内容title和内容title和内容有这么五个layout，都是title and content。那会儿我们还没有改这个名字，所以他打出来是title and content。这个时候我们就跟他讲了，比如说这个title and content strategy，在当前加载的这个conf PPT template里面就有以下多个可选。我们在代码里面加载了一个PPT模板，就刚给大家看的模板里面有五个都是title and content，然后让他记住layout name是加载出来的，这个其实the name且符合如下的命名方式，title and title number. 
	所以从这其实大家就能看出来，如果我们用这种随意的那样name，你要去写好它的正则表达式是无端的增加的难度是没有必要的。但我们这相当于预告了。因为就算是这里的type and type number，它其实就没法匹配。第一条它是没有number，然后需要加载的时候，需要加载的模板情况来生成对应的这个live grow，不要硬编码。那我们就往下看，可以通过扩展lout strategy类来实现多个可用的幻灯片布局大V好，简单来说就是修改了layout manager，根据布局名称生成可选布局组，扩展各个l strategy，随机从布局组中选择一个布局。我们看下他的具体改动，我们往下首先他这儿出现了问题，他只去照顾了title and content，另外三个他忘了，同时我们看一下它的list group在这儿，在之前的assign layout里面，它是从我们把两个窗口。
	让大家。
	看得清楚一点。
	0.2版本对之前我们的assign out是根据slide content。我有图像，我有bullet points我就返回这个，我只有图我就返回这个，我只有内容我就返回这个，我只有title我就返回这个，那这儿他把首先他把前面这三个忘了。其次他的assign out是直接从slide content输入，然后有一个内部的方法叫get layout group，就返回一个group。然后这group怎么写的呢？我们看到这有啊if title and content in their name，and slide content bullet points，聊group就要摁一下这个，这其实他做了什么事情呢？这段代码的逻辑就是他下面应该也有写写的不细。然后简单说一下，就是他直接去用这个in the aut name去匹配，相当于字符串的一个包含主串匹配我的left name，如果有这个，那么我就把它加到了out里面，这个其实是把意思都理解错了。
	然后我们再往下看啊，首先有问题，原来的四个lao strategy都需要估撸，而不是说我整体有一个l group然后我再去取。所以这个地方是是是绕绕的有问题的。然后要在积累当中增加这个成员，我先从一个节点让他开始改，那怎么改的呢？我们看到left strategy都需要有自己的group，就是每一个子类都需要自己的输入，这个应该好理解。然后那就把它放到鸡肋里面，然后接着往下，大家都有自己的这个四个子类都在这儿，没有遗忘。
	然后接着我们再往下看啊，它的get layout group这儿，这个地方他没改，但他建了一个layout group，然后这个laws group我们看看在assign的out，这他略微理解了一些意思。就比如说之前创建的是一个slide content，然后基于这个slide content的情况，在这儿基于这个slight company的情况，我去返回一个写死的模板，现在不是，我有一个layout group，然后这个group里面就相当于原来的这样的一组。只要我有多个的out，它都放在了我的group里面。一个二级的一个列表都在这group里面。然后我要去真正去取的时候，随机返回其中一个随机返回其中一个在create strategy strategies get layouts，再给搜一下。在这儿在上面随机返回其中的一个这个代码不讲太细了，大家应该能看到这个对话流，能理解这个过程的演变。
	然后第二就是我们看刚刚代码会发现还有一个问题，就是create strategy的这个方法它的位置是有问题的。Create strategy其实就是去生成这个lout group。而他是在什么时候去用的呢？它是在a line out时候才用的，而它的初始化的时候都是设置为空的，因为他不知道我们的layout manager会怎么样去调用。那理论上应该是在light manager初始化的时候，就把这些strategy全部都构造好了。A sign out的时候应该只用才对，所以我们这儿这让他去做改动。这个改动主要就是在这儿让我们的初始化布局的时候，就直接把这些state生成好了。然后在assign out的时候就只需要去获取就好了，在self strategy里面根据它的name就获取到了这里。
	好，那我们再往下看啊，我这边就按照这个推进往下去讲它的迭代了。大家可以再回头去细看这个聊天过程。这里有一个变化，就是四个派生的子类的strategy，就到这儿为止已经有一些变化了。在0.2里面我们看到在0.2里面这四个子类因为它是硬编码的，所以它的the out name肯定不一样。但是在我们的0.3版本里面，我们看这四个子类它的实现其实是一模一样的。它的不同的部分其实是layout group已经被抽象出来了。
	然后这个layout group真正调用它的时候都是一个随机选择，当然如果未来大家想要再去做的更细一点，可以再把这个子类给延展出来。什么意思呢？就是比如说只有主页的那个布局，它可能就是随机选的。或者说你可以说你有几种title，就是只有title的这个layout。然后它比如说有科技属性的是一个key，有什么汇报的是一种key，然后是做education的是一个key，而不是random choice。我不知道这个表达清楚没有，而有的仍然是可以random choice，它就纯粹是为了增加多样性。
	所以说我们在这儿为止，我们把这个四个子类就干掉了，四个派生的子类的get lio方法是完全相同的。然后他们的差异点其实已经通过这个layout group来进行处理。然后layout manager这些地方都没变，只是去改了刚刚那一部分。然后这儿我们可以去尝试有没有用了增加一个debug级别的log输出，查看布局组的情况。它就在咱们的这个位置增加了一个布局组的输出，那我们接着往下迭代，这儿就发现了一些问题。我们看到它的输出有提到创建了title only的布局组，创建了title and the content布局组，创建了开团的picture的布局组，然后都只有一个布局，但没有匹配上，就往下迭代第二主要点就是正则表达式来匹配了，为什么呢？其实在最开始的那个版本里我们就提到了，单纯用这个字符串匹配肯定是不行的，这已经开始使用正则表达式去匹配这种格式的名称了，那么这个一眼就能看出来还有问题，因为会出现没有number的情况，所以我们就直接往下走。
	这个正则表达式没有办法匹配这种情况和这种情况，那么我们自己就简化一下问题，相当于我们从这个过程当中，我们发现了这个layout name本身就做的不够规范。那我们去简化问题就是把像title only这种很特殊的名词把only就去掉，and其实也是很特殊的名词把它去掉。然后number作为一个很重要的variable，如果我们不从零开始计数的话，那么也会出现问题。我们就把比如说把title only就命名为title 0，那它其实就符合这个type number，然后其他的这个内容我们都叫type title content picture都叫type。
	到这儿我们还没有去解决这个and的问题。我们先往下看啊，确实我们看看这个GPT SO，他在理解这个正则表达式方面是挺有优势的。我们简化了这个问题之后，首先type number能够匹配title 0了，然后这个格式也能匹配title and content one，然后这个格式也能匹配。这里我们看到picture住了，但是这个正则表达式就变得非常的难懂。他就为了完成这三种格式的匹配，他写的这个正则表达式layout time。然后这里星号，他刚才也有解释，大家如果对正则表达式感兴趣的可以去详细读一读。他就是为了去匹配这三种格式，写出来了一个很复杂的rex，然后把这个东西引入到了我们的create strategy里面，然后再来做匹配，这个也是有问题的。这个问题我们就直接引入到了编码的方案了，还是匹配不了。
	他虽然说了这么多，还是匹配不了，为什么呢？我这边就直接给大家说是怎么演进过来的。核心就是在于首先它这段代码self strategy create strategy这里在正则表达式当中，他直接使用了这个layout的type。我们回到代码里面来看，that type在。在这里它直接使用了这个lout type，而这个lout type是不能被带入这里来的。
	大家发现了吗？就这个little type是一个是从哪儿来的呢？是从下面的create change进来的，是从这儿来的。所以这个辽的type是title title and content，title and picture. 
	这显然与我们的初衷是违背的。我们希望type应该是title content或者picture。而这个law lab传进去之后，它就变成了这种形态，这个形态再去郑州表达式里匹配怎么样都会出问题的，这是第一点。然后第二点，所以这里大家能看懂吗？不能直接使用layout type放到那个正则表达式里去，这里也写了实际需要的type种类，应该是title content picture，未来可能会扩展，所以其实应该定义一个康复的态度。而正则表达式当中的type，只要是content type就行了。
	然后在实际匹配的时候，我开始在讲课件的时候跟大家提过一个问题，当我们把它放成tape之后，那么title and content和content and title是一种strategy或者一种的out吗？在当下我们认为是一种，但如果要匹配这种顺序不同的类型组合，它的正则表达式也是很难写的。因为你不能说只要是其中一个就行了，你必须要匹配上，不然的话就失去意义了，所有的都变成了同一种。所以就用编码的方式来解决问题，用编码的方式将layout encoding成一个特定编号。不同的content type拥有不同的权重，这个是总的思路。这样做的好处就是解决了content的type顺序不同带来的问题。只要content type的类型和数量一致的话，就应该是同一种air type。因为它的编码是相同的。
	最后我们再简化了out的命名，这样方便我们的去获取这个content type的类型和数量，最终的格式，type type number，移除这个and，有了这样的一个思路之后，我们能看到，首先这是我们最终的这个截图，就是在课件里的怎么改的呢？这样就好理解了，不同的权重，这就是二的0次方，二的1次方，二的2次方。给大家去理解一下，这其实就是一个零一字符串，很像我们经典的这个编码问题，然后会有一个calculate layout encoding，简单来说就是这个layout名字里面它如果有title，它就有有这个一。然后如果他有这个content，他就再加2，他有picture就再加4，然后如果你是title and picture就1加4等于5，这是一个经典的编码的问题，最终的问题就变成了去计算权重计算权重就好了。然后我们只需要把这个the out name按照逗号去分开按照逗号去分开，因为最终是这个形式，按照逗号去split，split之后就变成了一个content type的数组。然后这个数组里面按照它的对应权重去做上就可以了，应该好理解。
	有了这样的一个calculate layout encoding，然后再往下面我们看到了这个初始化的策略也就简单了。只有title就是一，title加content就1加3，title加picture就1加4，title content picture就一加2加4。四种策略，然后assign the out的方式也就简洁了很多，到这儿为止，然后为了打印输出，我们把lout manager这里的策略生成好了之后，再加一个print方法，这个语法堂大家应该知道了，它会新增加一个方法，去打印我们的输出，就能看到liot manager的状态编码。每个编码有个布局对应的layout ID和lout name，不能这样，新增的这个方法会打印输出这样的一个结果。那么我们就能看到编码一就是两个布局，编码三四个布局，编码5两个布局。你如果想要做的更优雅一点，你甚至还可以编码这儿写成具体是什么。但因为我们的命名已经相对规范了，所以在这儿就能看出来在这儿就能看出来。
	然后我们再往下。这里then layout和get layout group需要去修改实现的逻辑，这是实际运行的时候的bug，因为这里的具体的实现，我们就看代码就好了。应该在上面。在在这儿，对，我们在这儿能看到它这个than out是去取通过slight content去取出一个layout group。而这个get layout group这里是这样去算的，就lt name loud ID在这个lt mapping item里面的话就去匹配。但其实已经不能用这个匹配逻辑了，我们应该去算权重，因为它只有4种结果。不知道这个时候大家编码的逻辑转过来没有，从一堆字符串的匹配转换成了根据你的layout name去算出一个值，而这个值只有4种情况，是这样的一个意思。
	那有了这样的一个设计之后，这个肯定就要改了，这里也要改了，就去算这个layout就好，算这个encoding就好了，所以他又改了，生成了一个叫做calculate content encoding，输入的是slight content，那这个时候也简洁了。Slight content因为它已经结构化了，所以你就可以去算的时候，一开始视频，那这个slide content里面有title，我就加一这个位置就是我们定义的这个位置，按权重来，有他我就加2，有他我就加4，最终返回一个code就完了。所以把一个复杂的你这个是什么情况都有可能的字符串正则匹配问题就转换成一个编码问题。而且因为本身我们的slight content已经结构化，所以通过这个方式去计算它的编码是非常稳定的。只要input poser稳定，这个部分就非常稳定，所以就解耦合了，不再去把这个事情绕在一起。
	好，有了这个改进之后，它这有一个bug是GTCO的bug，它刚刚生成的这个代码里面有content encoding。但是他把雷奥汀口径给搞没了。我猜测他的原因应该是因为上下文对话太长了。然后他的这个对话太长之后造成的问题，然后我告诉他这个layout come encoding没了，然后这个create drag函数要依赖它。但他还是坚定的认为可以去掉这个了encoding，但其实不行，因为content encoding它的输入是input powers解析之后，我们自己定义的那套power point slide和slide content结构化的。而layout encoding就他认为可以删掉，我认为不能删掉的是用来处理我们的那堆PPT模板里面的那堆名字，而那堆名字也是有可能多样化的。然后我们只能把它通过字符串处理变成一个的type的数组，再来进行计算，所以两个是功能不同的，但也许你可以再去做整合，但没有必要。因为一个是结构化的slide content，一个是the out name，是一个字符串，他去做了一些他说了这样的一个更新，但最后这儿我就没有再强行去掰掰掰他这个事情了。
	我用了两次的测试，他都认为这个地方可以删掉，但其实不用。最终的一个版本其实就是把在这个基础上把我的被删掉的calculate layout encoding放回来。其实就是我们最终的版本。我就给大家看一眼，最终的0.3可能这个部分会稍微需要一些。
	如果你自己对这方面的知识比较熟悉的话，会很顺畅。不然的话可能就得多看一看这个对话了。大家可以看到这份代码其实相对左边来说，就是把calculate lout encoding他认为应该删除的加回来。剩下的就跟之前的一样，包括我们的lao strategy就变得非常简单了，不再需要脂类子类了。Layout group，然后gay layout去random choice一个就好了。然后我们的layout manager初始化，这是我们的打印信息打印。因为它实现了这个函数，所以它可以直接输出self int它那么assign out，然后这create strategy。
	这个就是用编码的系统编码的这种机制来解决复杂的字符串正则匹配的这个问题。并且它可以同时享受到我们已经结构化之后的slap content这个自定义数据结构的好处。原来我们是要把模板里面的layout和slide content里面的内容去做匹配。现在他们都变成了两个数字编码之后的数字，只要这两个数字相等，那么就可以直接去使用。所以这个逻辑大家一定得得理解和get到它的好处。
	好，这个是我们的layout。那最终是怎么把他们端到端串起来的呢？其实他的这个结果我们可以实际来看一看，跑一跑，在在这儿。这个已经启动了。在这个位置，我重新启动一下，让大家看到它的过程。
	我们的radio server里面。Gradual server这加载了config chatbot，这就是我们H的chatbot。然后PPT template是新更新的PPT template它同样打用这个幻灯片布局，不同的点是说在上一个版本我们这儿用的是config里面写死的这个，放大一点。
	在上一个版本我们用的是。
	conflict里面写死的这个layout mapping。现在我们就是加载了一个模板，模板里面是什么的of making，我们就用什么样的the of making，然后模板里面的net mapping，我们把打印出来是长这样的了。规范化了，大家看到这个右边高亮的部分，规范化，规范化之后，下面有一些我们radio的handle function，一个是generate concerts，一个是handle generate，具体我们看到这儿有一个GR block，然后contents chat works，chat interval这儿响应的是generate contents。他们其实就是用我们的the chat box去生成内容，这跟我们的language mental是一样的思路，然后它生成的内容就是左边这个样子，我们先刷新一下。
	长这样的，这个是我们的place folder，然后head，然后下面是我们的generate button，有个generate slice。我们的左边这个部分generate slides。Generate slides的function是handle generate，这个地方我们重点看一下handle generate它获取到的slide content是什么呢？是我们最后一次的该生成的结果。所以是从history里面取出来的最后一次content，然后生成的这个结果其实是一个markdown的内容，这个markdown的内容给到pass input text，这个就相当于我们0.2里面从文件里面读取到的内容，再给到这个那那拿到的结果再去调用generate presentation，就PPT generator的这个方法，这样就串起来了。那不不同的点就是这个layout。那layout我们再看一下下面这部分，let out manager初始化完成，manager的状态，这里有这个输出，这个是在哪里加载的呢？是在这里打印的，就这里有个the auto manager的初始化。
	初始化完成之后，我们让它在构造函数里面用debug级别的信息打造打印了这样的一个日志，编码一两个布局，编码5编码三五个布局，编码51个布局，编码71个布局。然后有他们分别的layout ID这个就是PPTX，里面能对上号的那个ID，然后了name这个是PPTFPPT里面的那个名字，这个就完全能对应起来了。然后再往下面才是radio真正去启动的时候输出的日志，就我们在。在这儿，再往下才是它输出的日志。然后我们接着来看一下。
	比如说我们。
	讲一下这个介绍一下虫洞。
	这里就有了，我们看到卡了，有声音。这个chatbot chat with testy，这个大家有印象还记得这是我们南茜的chat word输出的一个结果，长这样的。然后左边是它的一个演示的结果，这个有点少内容。我们可以再深入问一下，比如说这个虫洞和平行宇宙什么关系？
	放大一点，就虫洞与平行宇宙的关系，虫洞的定义，虫洞与平行宇宙的联系，理论的支持，科学探讨与挑战中国在这方面的研究。
	中国在虫洞和平行宇宙研究方面的进展。物理研究所，北京和清华大学相关团队相关的影视题材。
	当然右边这也有输出，输出这个结果。
	这里有啊虫洞和平行宇宙相关的影视题材经典影视作品，那我们再试一试，这个没有试过将以上所有内容整理成一个power point。
	我们看一看，还有虫洞与平行宇宙研究概述，虫洞的概述、理论基础，虫洞的类型、性质、实验与观察，文化中的表现与平行宇宙的关系，理论的知识科学探讨中国重点研究方向与影视题材主题探讨文化影响。它也不是直接拼接的大范围，他其实还是去整合了。那这个时候我们再来点generate slides。这就开始输出了。Generate slides到这儿就开始调用我们的这个PPT generator最后生成了生成的结果在这儿，有一行可以下载当load打开。虫洞与平行宇宙研究概述，生成了这样的。
	一个路易。
	虫洞的概述，这三个是他选成一样的。一个是random的，这个random大家也可以改成用yell的，就这个生成器，它就不会出现连续页是一样的情况。这儿其实是留给大家去做这个探索的。文化的影响一共20页，当然这个模板大家可以再继续去扩充。
	好，这个就是我们check PPT0.3的这个内容。然后今天这一次课没homework，因为我们前面留的homework k也蛮多的了。希望大家在0.3的这个代码基础上，自己再去多研究这个模板库的扩充，以及我们的lead strategy。现在是random choice，我觉得可能你基于你的特定场景可以去试一些不同的strategy。但现在机制已经有保证了，就是我们的encoding的这套方法和系统。好，这是我们0.3版本的主要的产品研发和实践，看大家有什么问题我们再交流。
	大叔都不在了，还有在线的吗？敲个一，敲个2，前面敲个一。还有在线上的吗？小可2。
	大家有什么问题吗？还是有人的。
	大家有什么问题吗？还是因为没有，后面大家就没问题了。
	大家都没问题了吗？我再去拿瓶水。
	第一个问题，whisper中文识别差怎么处理？我们的微调训练营专门有一节课实战就教大家怎么解决这个问题，会训练一个中文识别比较准的best per。然后模板里面如果有多个图、多个文本、多个种类排列出组合出来，代码还是可能重复的。这个我开始讲的时候就提过了，如果你的模板库足够丰富的时候，你可以做这件事情，不然的话你就是在给自己找麻烦对。
	因为layout是一个很主观的事情，就是你认为他们是一类可以放到一个group里，就可以放到一个group里。对，甚至那个content type都是可以再去分的。因为你想象一下它是怎么一步一步来的，就我们的模板是怎么来的。我们的模板是我们自己造的，然后我们在造的时候，我们认为他们是不一样的，其实他们是什么呢？他们是不一样的。Place holder. 
	然后the place holder，比如说我把它挪到这儿来，跟它原来是同一种layout group。如果你认为它不是在美学上，你不承认它是同一种，那显然就不能用刚刚的方式来分类。但是你有多少个模板去去组织起来，才值得你去这样做细分类。如果还没有的话，先把出分类的做好，或者你目标就是做一个垂类的。你只做这个performance review，就是绩效考察的这个，那你可以做细一点。你甚至可以把图都做一些预制的图，比如像这些都是预制的图，这个完全取决于你的目标了。对。然后point是说这套encoding的系统就算顺序什么的变了，仍然是可以有用的。你无非是这里有坐标，就你的content type也是有坐标的，这个坐标也是能带入到那套coding系统里的对。
	刚刚有同学问了另一个，对，就是我刚刚提到的对，自由度更高是没问题的。但是再高的自由度，只要是你是一个用模板的人，你要一致性，那你就会用模板的套路来考虑问题。对，就不能那么自由，你的自由太高了，是因为你的PPT没有那么统一。然后只要你是用模板的套路，就可以回到leave group这个思路上面来。然后无非是说这个leave group要怎么样去扩展，比如说把位置引入进来。位置引入进来我刚刚提到了，他有本来就有四个关键的坐标点，这个坐标点是可以引入到encoding里面来。
	还有就是把你的主题什么的，就给你的layout打上一些属性。除了刚刚我说的内容的类型以外，打上一些属性，科技属性、汇报的属性、人文属性、电影题材等等这些都可以。我不知道我这个有没有描述清楚，就layout本身这个strategy是可以扩展很多的，现在我们都还没往里面加attributes对吧？那这个FQ就是跟内容隔开的另一个维度，甚至你可以有VIP的那out的和非VIP的。10点18了，我们再回答最后一个问题，看大家有什么问题，因为我看大家都是两三分钟之前提的。
	他还有问题吗？我也没问题了。
	行，四分钟了，大家没什么问题就群里再问，我们可以在群里再交流。好，今天就到这里。